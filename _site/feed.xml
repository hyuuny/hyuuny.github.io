<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  
  <channel>
    <title> Hyuuny`s Blog  </title>
    <description>객체지향과 DDD에 관심이 많은 백엔드개발자로서, 최근에는 리눅스와 도커에 관심이 생겨 함께 공부하고 있습니다.</description>
    <link>https://hyuuny.github.io/</link>
    <atom:link href="https://hyuuny.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 31 Oct 2021 18:58:15 +0900</pubDate>
    <lastBuildDate>Sun, 31 Oct 2021 18:58:15 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>Configuration과 Singleton</title>
        <description>&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

      &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;memberService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MemberServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;orderService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OrderServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MemoryMemberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; 

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;memberService 빈을 만드는 코드를 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memberRepository()&lt;/code&gt;를 호출한다.&lt;/li&gt;
  &lt;li&gt;orderService 빈을 만드는 코드도 동일하게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memberRepository()&lt;/code&gt;를 호출한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new연산자&lt;/code&gt;를 통해 각각 다른 2개의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MemoryMemberRepository&lt;/code&gt;가 생성되면서 싱글톤이 깨지는 것 처럼 보이는데, 스프링 컨테이너는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;이 붙은 메서드를 한 번만 호출해서 등록하고 이를 재사용한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;configuration과-바이트코드-조작&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;@Configuration과 바이트코드 조작&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;스프링 컨테이너는 싱글톤 레지스트리다. 따라서 스프링 빈이 싱글톤이 되도록 보장해주어야 한다. 그런데 스프링이 자바 코드까지 어떻게 하기는 어렵다. 위 코드를 보면 분명 3번 호출되어야 하는 것이 맞다. 그래서 스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용한다.&lt;br /&gt;
모든 비밀은 &lt;strong&gt;@Configuration 을 적용한 AppConfig&lt;/strong&gt;에 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;configurationDeep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ac&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;AnnotationConfigApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//AppConfig도 스프링 빈으로 등록된다.&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bean = &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//출력: bean = class hello.core.AppConfig$$EnhancerBySpringCGLIB$$bd479d70&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AnnotationConfigApplicationContext&lt;/code&gt;에 파라미터로 넘긴 값은 스프링 빈으로 등록된다. 그래서 AppConfig도 스프링 빈이 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;순수한 클래스라면 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class hello.core.AppConfig&lt;/code&gt;&lt;/strong&gt;와 같이 출력되어야 하지만,&lt;/p&gt;

&lt;p&gt;AppConfig 스프링 빈을 조회해서 클래스 정보를 출력해보면&lt;br /&gt;
&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class hello.core.AppConfig$$EnhancerBySpringCGLIB$$bd479d70&lt;/code&gt;&lt;/strong&gt;와 같이 출력된다.&lt;/p&gt;

&lt;p&gt;스프링 빈을 조회해서 출력한 클래스 명에 xxxCGLIB가 붙은 것을 확인 할 수 있는데, 이것은 내가 만든 클래스가 아니라 &lt;strong&gt;스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고, 이를 스프링 빈으로 등록했기 때문이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/configuration.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;AppConfig를 상속받은 임의의 클래스가 싱글톤이 보장되도록 해준다.&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;AppConfig@CGLIB 예상 코드&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memoryMemberRepository가&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;이미&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;스프링&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;컨테이너에&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;등록되어&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;있으면&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;스프링&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;컨테이너에서&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;찾아서&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//스프링 컨테이너에 없으면&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;기존&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;로직을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;호출해서&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemoryMemberRepository를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;생성하고&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;스프링&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;컨테이너에&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;등록&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;@Bean이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다.
    &lt;ul&gt;
      &lt;li&gt;그로 인해 싱글톤이 보장 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;AppConfig@CGLIB는 AppConfig의 자식 타입이므로, AppConfig 타입으로 조회 할 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;@Configuration을 적용하지 않고, @Bean만 적용한 경우&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 빈으로 등록되지만, 매번 객체를 생성한다.(싱글톤을 보장하지 않음)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 31 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/configuration/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/configuration/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>Singleton, SingletonContainer</title>
        <description>&lt;h2 id=&quot;싱글톤sigleton&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;싱글톤(Sigleton)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다.&lt;/li&gt;
  &lt;li&gt;객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다.
    &lt;ul&gt;
      &lt;li&gt;private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;싱글톤 패턴의 문제점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.&lt;/li&gt;
  &lt;li&gt;의존관계상 클라이언트가 구체 클래스에 의존한다. DIP를 위반한다.&lt;/li&gt;
  &lt;li&gt;클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.&lt;/li&gt;
  &lt;li&gt;테스트하기 어렵다.&lt;/li&gt;
  &lt;li&gt;내부 속성을 변경하거나 초기화 하기 어렵다.&lt;/li&gt;
  &lt;li&gt;private 생성자로 자식 클래스를 만들기 어렵다.&lt;/li&gt;
  &lt;li&gt;결론적으로 유연성이 떨어진다.&lt;/li&gt;
  &lt;li&gt;안티패턴으로 불리기도 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;싱글톤-컨테이너sigleton-container&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;싱글톤 컨테이너(Sigleton Container)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.&lt;/li&gt;
  &lt;li&gt;스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.&lt;/li&gt;
  &lt;li&gt;스프링 컨테이너의 이런 기능 덕분에 싱글턴 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.&lt;/li&gt;
  &lt;li&gt;싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다.&lt;/li&gt;
  &lt;li&gt;DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;싱글톤 컨테이너 테스트&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/singleton-test1-1.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AppConif 설정 클래스에서 각각(memberService1, memberService2) 가져온다.&lt;/li&gt;
  &lt;li&gt;memberService1과 memberService2가 &lt;strong&gt;같은 객체인지&lt;/strong&gt; 확인한다.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/singleton-test1-2.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;스프링 컨테이너 덕분에 고객의 요청이 올 때 마다 &lt;strong&gt;객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유&lt;/strong&gt;해서 효율적으로 재사용할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이를 그림으로 표현하면 아래와 같다.
&lt;img src=&quot;/assets/images/spring/singleton-test1-3.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;스프링의 기본 빈 등록 방식은 싱글톤이지만, 싱글톤 방식만 지원하는 것은 아니다. 요청할 때 마다 새로운 객체를 생성해서 반환하는 기능도 제공한다.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;싱글톤-방식의-주의점&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;싱글톤 방식의 주의점&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 &lt;strong&gt;싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;즉, 무상태(stateless)로 설계해야 한다.
    &lt;ul&gt;
      &lt;li&gt;특정 클라이언트에 의존적인 필드가 있으면 안된다.&lt;/li&gt;
      &lt;li&gt;특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;가급적 읽기만&lt;/strong&gt; 가능해야 한다.&lt;/li&gt;
      &lt;li&gt;필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 27 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/sington/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/sington/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>IoC, DI, Container</title>
        <description>&lt;h2 id=&quot;제어의-역전inversion-of-control&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;제어의 역전(Inversion of Control)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행했다. 한마디로 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다.&lt;/li&gt;
  &lt;li&gt;AppConfig가 등장한 이후에 구현 객체는 자신의 로직을 실행하는 역할만 담당한다. 프로그램의 제어 흐름은 이제 AppConfig가 가져간다.
    &lt;ul&gt;
      &lt;li&gt;예를 들어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt; 은 필요한 인터페이스들(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repository&lt;/code&gt;와 같은)을 호출하지만 어떤 구현 객체들이 실행될지 모른다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그램에 대한 제어 흐름에 대한 권한은 모두 AppConfig가 가지고 있다. 심지어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt;도 AppConfig가 생성한다.
    &lt;ul&gt;
      &lt;li&gt;AppConfig는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt; 이 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderService&lt;/code&gt; 인터페이스의 다른 구현 객체를 생성하고 실행할 수 도 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이렇듯 프로그램의 &lt;strong&gt;제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)&lt;/strong&gt;이라 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;프레임워크와 라이브러리&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 프레임워크이다.&lt;/li&gt;
  &lt;li&gt;내가 작성한 코드가 직접 제어의 흐름을 담당한다면 프레임워크가 아니라 라이브러리다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;의존관계-주입-didependency-injection&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;의존관계 주입 DI(Dependency Injection)&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DiscountPolicy&lt;/code&gt; 인터페이스에 의존한다. 실제 어떤 구현 객체가 사용될지는
모른다.&lt;/li&gt;
  &lt;li&gt;의존관계는 &lt;strong&gt;정적인 클래스 의존 관계&lt;/strong&gt;와, &lt;strong&gt;실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계&lt;/strong&gt; 둘을 분리해서 생각해야 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;정적인 클래스 의존관계&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다. 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MemberRepository&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DiscountPolicy&lt;/code&gt;에 의존한다는 것을 알 수 있다.
그런데 이러한 클래스 의존관계 만으로는 실제 어떤 객체가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt;에 주입 될지 알 수 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/di1.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;동적인 객체 인스턴스 의존 관계&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;애플리케이션 실행 시점에&lt;/strong&gt; 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/di2.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;애플리케이션 &lt;strong&gt;실행 시점(런타임)&lt;/strong&gt;에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 &lt;strong&gt;의존관계 주입&lt;/strong&gt;이라 한다.&lt;/li&gt;
  &lt;li&gt;객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다.&lt;/li&gt;
  &lt;li&gt;의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.&lt;/li&gt;
  &lt;li&gt;의존관계 주입을 사용하면 &lt;strong&gt;정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경&lt;/strong&gt;할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ioc-컨테이너-di-컨테이너&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;IoC 컨테이너, DI 컨테이너&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;AppConfig 처럼 &lt;strong&gt;객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 DI 컨테이너&lt;/strong&gt;라 한다.&lt;/li&gt;
  &lt;li&gt;의존관계 주입에 초점을 맞추어 &lt;strong&gt;최근에는 주로 DI 컨테이너&lt;/strong&gt;라 한다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/IoC-DI-Container/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/IoC-DI-Container/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>ApplicationContext</title>
        <description>&lt;h2 id=&quot;config-기반-bean-설정&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;Config 기반 Bean 설정&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;memberService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MemberServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MemoryMemberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;orderService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OrderServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountpolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;discountpolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RateDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;AppConfig에 설정을 구성한다는 뜻의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Configuration&lt;/code&gt;을 붙여준다.&lt;/li&gt;
  &lt;li&gt;각 메서드에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;을 붙여준다. 이렇게 하면 &lt;strong&gt;메서드에서 반환하는 객체를 스프링 컨테이너에 스프링 빈으로 등록&lt;/strong&gt;한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;스프링-컨테이너에-등록한-bean-꺼내서-사용하기&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;스프링 컨테이너에 등록한 Bean 꺼내서 사용하기&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// parameter : @Coufiguration이 붙은 구성 클래스&lt;/span&gt;
 &lt;span class=&quot;nc&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;applicationContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnnotationConfigApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;// parameter : 빈이름, 반환타입&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;applicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;memberService&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);/&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;memberA&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Grade&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;VIP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;memberService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ApplicationContext를 스프링 컨테이너&lt;/strong&gt;라 한다.&lt;/li&gt;
  &lt;li&gt;기존에는 개발자가 AppConfig 를 사용해서 직접 객체를 생성하고 DI를 했지만, 이제부터는 스프링 컨테이너를 통해서 사용한다.&lt;/li&gt;
  &lt;li&gt;스프링 컨테이너는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Configuration&lt;/code&gt;이 붙은 AppConfig 를 설정(구성) 정보로 사용한다. 여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 이렇게 &lt;strong&gt;스프링 컨테이너에 등록된 객체를 스프링 빈&lt;/strong&gt;이라 한다.&lt;/li&gt;
  &lt;li&gt;스프링 빈은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;이 붙은 &lt;strong&gt;메서드의 명을 스프링 빈의 이름으로 사용&lt;/strong&gt;한다.&lt;/li&gt;
  &lt;li&gt;이전에는 개발자가 필요한 객체를 AppConfig 를 사용해서 직접 조회했지만, 이제부터는 스프링 컨테이너를 통해서 필요한 스프링 빈(객체)를 찾아야 한다. 스프링 빈은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applicationContext.getBean()&lt;/code&gt; 메서드를 사용해서 찾을 수 있다.&lt;/li&gt;
  &lt;li&gt;기존에는 개발자가 직접 자바코드로 모든 것을 했다면 이제부터는 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/spring-context.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 부트 실행 시, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;이 만들어지는 모습&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;스프링-컨테이너-생성-과정&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;스프링 컨테이너 생성 과정&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너는 XML(거의 사용 안 함)을 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스로 만들 수 있다.&lt;/li&gt;
  &lt;li&gt;더 정확하게는 스프링 컨테이너를 부를 때 BeanFactory , ApplicationContext 로 구분하지만,  BeanFactory 를 직접 사용하는 경우는 거의 없으므로 일반적으로 ApplicationContext 를 스프링 컨테이너라 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;1. 스프링 컨테이너 생성&lt;/strong&gt;
&lt;img src=&quot;/assets/images/spring/application-context1.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너를 생성할 때는 구성 정보(여기서는 AppConfig.class)를 지정해줘야 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. 스프링 빈 등록&lt;/strong&gt;
&lt;img src=&quot;/assets/images/spring/application-context2.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너는 파라미터 넘어온 설정 클래스 정보를 읽어, @Bean 으로 등록된 메서드의 반환 타입을 스프링의 빈으로 등록한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3. 스프링 빈 의존관계 설정 - 준비&lt;/strong&gt;
&lt;img src=&quot;/assets/images/spring/application-context3.png&quot; alt=&quot;img.png&quot; /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 스프링 빈 의존관계 설정 - 완료&lt;/strong&gt;
&lt;img src=&quot;/assets/images/spring/application-context4.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너는 설정 정보를 참고하여 의존관계를 주입(DI)한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;beanfactory와-applicationcontext&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;BeanFactory와 ApplicationContext&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/spring/application-context5.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;beanfactory&quot;&gt;&lt;strong&gt;BeanFactory&lt;/strong&gt;&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너의 최상위 인터페이스다.&lt;/li&gt;
  &lt;li&gt;스프링 빈을 관리하고 조회하는 역할을 담당한다.&lt;/li&gt;
  &lt;li&gt;getBean() 을 제공한다.&lt;/li&gt;
  &lt;li&gt;지금까지 우리가 사용했던 대부분의 기능은 BeanFactory가 제공하는 기능이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/application-context6.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;applicationcontext&quot;&gt;&lt;strong&gt;ApplicationContext&lt;/strong&gt;&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;BeanFactory 기능을 모두 상속받아서 제공한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메시지소스를 활용한 국제화 기능(MessageSource)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;환경변수(EnvironmentCapable)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;로컬, 개발, 운영등을 구분해서 처리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;애플리케이션 이벤트(ApplicationEventPublisher)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;이벤트를 발행하고 구독하는 모델을 편리하게 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;편리한 리소스 조회(ResourceLoader)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/ApplicationContext/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/ApplicationContext/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>SOLID 원칙</title>
        <description>&lt;p&gt;클린코드로 유명한 로버트 마틴이 &lt;strong&gt;좋은 객체 지향 설계의 5가지 원칙&lt;/strong&gt;을 정리하였다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SRP: 단일 책임 원칙(Single Responsibility Principle)&lt;/li&gt;
  &lt;li&gt;OCP: 개방-폐쇄 원칙(Opne Closed Principle)&lt;/li&gt;
  &lt;li&gt;LSP: 리스코프 치환 원칙(Liskov Substitution Principle)&lt;/li&gt;
  &lt;li&gt;ISP: 인터페이스 분리 원칙(Interface Segregation Principle)&lt;/li&gt;
  &lt;li&gt;DIP: 의존관계 역전 원칙(Dependency Inversion Principle)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;srp-단일-책임-원칙single-responsibility-principle&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;SRP 단일 책임 원칙(Single Responsibility Principle)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;한 클래스는 하나의 책임&lt;/strong&gt;을 가져야 한다.&lt;/li&gt;
  &lt;li&gt;하나의 책임이라는 기준은 모호하다.
    &lt;ul&gt;
      &lt;li&gt;클 수도 있고, 작을 수도 있다.&lt;/li&gt;
      &lt;li&gt;문맥과 상황에 따라 다르다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;중요한 기준은 변경&lt;/strong&gt;이다. 변경이 있을 때, 파급효과가 적으면 단일 책임원칙을 잘 따른 것
    &lt;ul&gt;
      &lt;li&gt;예) UI 변경, 객체의 생성과 사용을 분리&lt;/li&gt;
    &lt;/ul&gt;

    &lt;hr /&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ocp-개방-폐쇄-원칙opne-closed-principle&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;OCP 개방-폐쇄 원칙(Opne Closed Principle)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;소프트웨어 요소는 &lt;strong&gt;확장에는 열려&lt;/strong&gt;있으나, &lt;strong&gt;변경에는 닫혀&lt;/strong&gt;있어야 한다.&lt;/li&gt;
  &lt;li&gt;다형성을 활용하자.(역할과 구현을 분리)&lt;/li&gt;
  &lt;li&gt;인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현하자.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;예시&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Service 의존하고 있는 MemberReposiroty를 JdbcMEmberReposiroty로 변경해야 하는 상황.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//private MemberRepository memberRepository = new MemberRepository(); // 기존코드&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JdbcMemberReposiroty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 변경 코드&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;구현 객체를 변경하면 클라이언트 코드를 변경해야한다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;분명 다형성을 사용했지만, OCP 원칙을 지킬 수 없다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
    &lt;ul&gt;
      &lt;li&gt;여기서는 &lt;strong&gt;MemberReposiroty를 인터페이스로 두고, 이를 구현&lt;/strong&gt;하도록 하자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Service는 Repository 인터페이스만 바라봄으로써, Repository의 &lt;strong&gt;구현체가 무엇이든 상관 없다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;lsp-리스코프-치환-원칙liskov-substitution-principle&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;LSP 리스코프 치환 원칙(Liskov Substitution Principle)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램의 객체는 &lt;strong&gt;프로그램의 정확성을 깨드리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야&lt;/strong&gt; 한다.&lt;/li&gt;
  &lt;li&gt;다형성에서
    &lt;ul&gt;
      &lt;li&gt;하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것,&lt;/li&gt;
      &lt;li&gt;다형성을 지원하기 위한 원칙,&lt;/li&gt;
      &lt;li&gt;인터페이스를 구현한 구현체는 믿고 사용하려면 이 원칙이 필요하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단순히 컴파일에 성공한다고 다가 아니다.
    &lt;ul&gt;
      &lt;li&gt;예) 자동차 인터페이스의 엑셀은 앞으로 가는 기능
        &lt;ul&gt;
          &lt;li&gt;뒤로 가도록 구현하면 LSP 위반&lt;/li&gt;
          &lt;li&gt;느리더라도 앞으로 가야 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;isp-인터페이스-분리-원칙interface-segregation-principle&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;ISP 인터페이스 분리 원칙(Interface Segregation Principle)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;특정 클라이언트를 위한 인터페이스 &lt;strong&gt;여러 개가 범용 인터페이스 하나보다 낫다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;예) 자동차 인터페이스 -&amp;gt; 운전 인터페이스, 정비 인터페이스로 분리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인터페이스가 명확해지고, 대체 가능성이 높아&lt;/strong&gt;진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;dip-의존관계-역전-원칙dependency-inversion-principle&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;DIP 의존관계 역전 원칙(Dependency Inversion Principle)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로그래머는 &lt;strong&gt;“추상화에 의존해야지, 구체화에 의존하면 안된다.” 의존성 주입은 이 원칙을 따르는 방법 중 하나&lt;/strong&gt;다.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻&lt;/strong&gt;
&lt;strong&gt;역할(Role)에 의존하게 해야 한다는 것과 같다.&lt;/strong&gt; (구현에 의존하지 말자!)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클라이언트가 &lt;strong&gt;인터페이스에 의존하야 유연하게 구현체를 변경할 수 있다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;구현체에 의존하게 되면 변경이 아주 어려워진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 24 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/SOLID/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/SOLID/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>REST API란</title>
        <description>&lt;p&gt;REST는 Representational State Transfer의 약자로 아키텍처 스타일이다. 아키텍처 스타일은 아키텍처 패턴과는 조금 다른데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;아키텍처 패턴은 어떤 반복되는 문제 상황을 해결하는 도구&lt;/code&gt;이고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;아키텍처 스타일은 반복되는 아키텍처 디자인을 의미&lt;/code&gt;한다.&lt;br /&gt;
&lt;strong&gt;REST 아키텍처 스타일은 6가지 제약조건으로 구성되며, 이 가이드 라인을 따르는 API를 RESTfull API&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;REST 제약 조건&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;클라이언트-서버(Client-Server)&lt;/li&gt;
  &lt;li&gt;상태가 없는(stateless)&lt;/li&gt;
  &lt;li&gt;캐시되는 데이터(Cacheable)&lt;/li&gt;
  &lt;li&gt;일관적인 인터페이스(Uniform Interface)&lt;/li&gt;
  &lt;li&gt;레이어 시스템(Layered System)&lt;/li&gt;
  &lt;li&gt;코드-온-디맨트(Code-On-Demand)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;클라이언트-서버client-server&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;클라이언트-서버(Client-Server)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;클라이언트-서버는 리소스를 관리하는 서버가 존재하고, 다수의 클라이언트가 리소스를 소비하려고 네트워크를 통해 서버에 접근하는 구조를 말한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이런 구조 중 우리에게 가장 친숙한 것이 바로 웹 애플리케이션이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;리소스란 REST API가 리턴할 수 있는 모든 것(HTML, JSON, 이미지 등)을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;상태가-없는stateless&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;상태가 없는(stateless)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;상태가 없다는 것은 클라이언트가 서버에 요청을 보낼 때, 이전 요청의 영향을 받지 않음을 의미한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 로그인의 경우 서버는 로그인 상태를 유지하지 못하므로, 요청을 보낼 때마다 로그인 정보를 항상 함께 보내야 한다. 리소스를 수정한 후 수정한 상태를 유지해야 하는 경우에는 서버가 아닌 DB와 같은 곳에 상태를 저장해야한다.&lt;/p&gt;

&lt;p&gt;HTTP는 기본적으로 상테가 없는 프로토콜이다. 따라서 HTTP를 사용하는 웹 애플리케이션은 기본적으로 상태가 없는 구조를 따른다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;캐시되는-데이터cacheable&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;캐시되는 데이터(Cacheable)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;서버에서 리소스를 리턴할 때 캐시가 가능한지 아닌지 명시할 수 있어야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTTP에서는 cache-control이라는 헤더에 리소스의 캐시 여부를 명시할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;일관적인-인터페이스uniform-interface&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;일관적인 인터페이스(Uniform Interface)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;일관적인 인터페이스란, 시스템 또는 애플리케이션의 리소스에 접근할 때 인터페이스가 일관적이어야 한다는 뜻이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 어떤 정보를 가져오기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://example.com/water&lt;/code&gt;를 사용했다고 하자. 이때 정보를 업데이트 하는 데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://example2.com/water&lt;/code&gt;를 사용한다면 이것은 URI의 일관성이 있다고 볼 수 없다.&lt;/p&gt;

&lt;p&gt;또 다른 예로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://example.com/water&lt;/code&gt;는 JSON 형식의 리소스를 리턴했다. 그런데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://example.com/book&lt;/code&gt;은 HTML을 리턴했다. 이런 인터페이스는 타입에 일관성이 있다고 볼 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;요청의 형태와 응답의 형태가 애플리케이션 전반에 걸쳐 일관적이어야 한다는 것이 일관적인 인터페이스 방침이다&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;레이어-시스템layered-system&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;레이어 시스템(Layered System)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;클라이언트가 서버에 요청을 할 때, 여러 개의 레이어로 된 서버를 거칠 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 서버가 인증 서버, 캐싱 서커, 로드 밸런서를 거쳐서 최종적으로 애플리케이션에 도착한다고 가정하자. &lt;strong&gt;이 사이의 레이어들은 요청과 응답에 어떤 영향을 미치지 않으며, 클라이언트는 레이어 존재 유무를 알지 못한다&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;코드-온-디맨트code-on-demand&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;코드-온-디맨트(Code-On-Demand)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;클라이언트는 서버에 코드를 요청할 수 있고, 서버가 리턴한 코드를 실행할 수 있다.(선택 사항)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;REST는 HTTP와 다르다. REST는 HTTP를 이용해 구현하기 쉽고 대부분 그렇게 구현하지만, &lt;strong&gt;REST는 아키텍처&lt;/strong&gt;이고, &lt;strong&gt;HTTP는 REST 아키텍처를 구현할 때 사용하면 쉬운 프로토콜&lt;/strong&gt;이다.&lt;/p&gt;

</description>
        <pubDate>Fri, 15 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/rest-api/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/rest-api/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>OSI 7계층</title>
        <description>&lt;p&gt;과거에는 통신용 규약이 표준화되지 읺았고 각 벤더에서 별도로 개발했기 때문에 호환되지 않는 시스템이나 애플리케이션이 많았고 통신이 불가능했다. 이를 하나의 규약으로 통합하려는 노력이 현재의 OSI 7계층으로 남게 되었고 대부분의 프로토콜이 TCP/IP 프로토콜 스택 기반으로 되어 있다.&lt;/p&gt;

&lt;p&gt;OSI 7계층은 두 가지 계층으로 나눌 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1~4 계층 : 데이터 플로 계층(Data Flow Layer) / 하위 계층(Lower Layer)&lt;/li&gt;
  &lt;li&gt;5~7 계층 : 애플리케이션 계층(Application Layer) / 상위 계층(Upper Layer)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1계층피지컬-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;1계층(피지컬 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1계층은 물리 계층으로 물리적 연결과 관련된 정보를 정의한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;주로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전기 신호를 전달하는데 초점이 맞추어져&lt;/code&gt; 있다.&lt;/p&gt;

&lt;p&gt;1계층에서는 들어온 전기 신호를 그대로 잘 전달하는 것이 목적이므로, 전기 신호가 1계층 장비에 들어오면 이 전기 신호를 재생성하여 내보낸다.&lt;/p&gt;

&lt;p&gt;주소의 개념이 없으므로, 전기 신호가 들어온 포트를 제외하고 모든 포트에 같은 전기 신호를 전송한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주요 장비 : 허브(hub), 리피터(Repeater), 케이블(Cable), 커넥터(Connector), 트랜시버(Tranceiver), 탭(TAP)
    &lt;ul&gt;
      &lt;li&gt;허브, 리피터 : 네트워크 통신을 중재하는 네트워크 장비&lt;/li&gt;
      &lt;li&gt;트랜시버 : 컴퓨터의 랜 카드와 케이블을 연결하는 장치&lt;/li&gt;
      &lt;li&gt;탭 : 네트워크 모니터링과 패킷 분석을 위해 전기 신호를 다른 장비로 복제함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2계층데이터-링크-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;2계층(데이터 링크 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;2계층은 데이터 링크 계층으로 전기 신호를 모아 우리가 알아볼 수 있는 데이터 형태로 처리한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;1계층과는 다르게 전기 신호를 정확히 전달하기보다는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주소 정보를 정의하고 정확한 주소로 통신이 되도록 하는 데 초점이 맞추어져&lt;/code&gt; 있다.&lt;/p&gt;

&lt;p&gt;출발지와 도착지 주소를 확인하고, 내게 보낸 것이 맞는지, 또는 내가 처리해야 하는지에 대해 검사한 후 데이터 처리를 수행한다.&lt;/p&gt;

&lt;p&gt;MAC주소라는 주소 체계가 있어 네트워크 인터페이스 카드와 스위치 모두 MAC 주소를 이해할 수 있고, 스위치는 MAC 주소를 보고 통신해야 할 포트를 지정해 내보내는 능력이 있다.&lt;/p&gt;

&lt;p&gt;동시에 여러 명과 통신하기 때문에 플로 컨트롤(Flow Control)을 수행한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/osi7layer/data-link.jpeg&quot; alt=&quot;img.png&quot; /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주요 장비 : 네트워크 인터페이스 카드, 스위치
    &lt;ul&gt;
      &lt;li&gt;네트워크 인터페이스 카드 : 자신에게 들어오는 전기 신호가 아니면 버리고, 맞으면 데이터를 메모리에 적재&lt;/li&gt;
      &lt;li&gt;스위치 : 주소 습득 과정을 통해 얻은 데이터를 기반으로 포트를 적절히 필터링하고, 정확한 포트로 포워딩&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/osi7layer/switch.jpeg&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3계층네트워크-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;3계층(네트워크 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;3계층에는 IP 주소와 같은 논리적인 주소가 정의된다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 통신을 할 떄는 2계층의 물리적인 MAC 주소와 3계층의 논리적인 IP 주소가 사용된다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3계층을 이해할 수 있는 장비나 단말은 네트워크 주소 정보를 이용해 자신이 속한 네트워크와 원격지 네트워크를 구분할 수 있고, 원격지 네트워크를 가려면 어디로 가야 하는지 경로를 지정한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주요 장비 : 라우터
    &lt;ul&gt;
      &lt;li&gt;라우터 : IP 주소를 사용해 최적의 경로를 찾고, 해당 경로로 패킷을 전송&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/osi7layer/router.jpeg&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;4계층트랜스포트-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;4계층(트랜스포트 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;4계층은 실제로 데이터들이 정상적으로 잘 보내지도록 확인하는 역할을 한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;패킷 네트워크는 데이터를 분할해 패킷에 실어보내다 보니 중간에 유실되거나, 순서가 뒤바뀔 수 있다. 이 문제를 바로 잡아주는 역할을 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;패킷에 보내는 순서를 명시하는 것이 시퀀스 번호이고, 받는 순서를 나타내는 것이 ACK 번호이다.&lt;/code&gt; 또한, 포트 번호를 사용해 상위 애플리케이션을 구분한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주요 장비 : 로드 밸런서, 방화벽
    &lt;ul&gt;
      &lt;li&gt;로드 밸런서 : 부하 분산&lt;/li&gt;
      &lt;li&gt;방화벽 : 패킷 통과 또는 차단&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;5계층세션-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;5계층(세션 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;5계층인 세션 계층은 양 끝단의 응용 프로세스가 연결을 성립하도록 도와주고 연결이 안정적으로 유지되도록 관리하며, 작업 완료 후에는 연결을 끊는 역할을 수행한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCP/IP 세션을 만들고 없애는 책임을 가지며, 에러로 중단된 통신에 대한 에러 복구와 재전송도 수행한다.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;6계층프레젠테이션-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;6계층(프레젠테이션 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;6계층인 프레젠테이션 계층은 표현 방시깅 다른 애플리케이션이나 시스템 간의 통신을 돕기 위해 하나의 통일된 구문 형식으로 변환시키는 기능을 수행한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;변환기 역할을 수행하는 계층으로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MIME 인코딩이나 암호화, 압축, 코드 변환과 같은 동작이 이루어진다.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;7계층애플리케이션-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;7계층(애플리케이션 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;7계층인 애플리케이션 계층은 애플리케이션 프로세스를 정의하고, 애플리케이션 서비를 수행한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;네트워크 소프트웨어의 UI 부분이나, 사용자 입/출력 부분을 정의하는 것이 애플리케이션 계층의 역할이다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;대표적인 프로토콜 : FTP, SMTP, HTTP, TELNET&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;계층별-주요-프로토콜-및-장비&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;계층별 주요 프로토콜 및 장비&lt;/span&gt;&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;계층&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;주요 프로토콜&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;장비&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;애플리케이션 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HTTP, SMP, SMTP, STUN, TFTP, TELNET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ADC, NGFW, WAF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;프레젠테이션 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TLS, AFP, SSH&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;세션 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;L2TP, PPTP, NFS, RPC, PTCP, SIP, SSH&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;트랜스포트 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TCP, UDP, SCTP, DCCP, AH, AEP&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;로드 밸런서, 방화벽&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;네트워크 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ARP, IPv4, IPv6, NATm IPSec, 라우팅 프로토콜&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;라우터, L3 스위치&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;데이터 링크 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;IEEE 802.2, FDDI&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;스위치, 브릿지, 네트워크 카드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;피지컬 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RS-232, RS-449, V.35, S 등의 케이블&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;케이블, 허브, 탭(TAP)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Fri, 15 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/network/osi7layer/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/network/osi7layer/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>network</category>
        
      </item>
    
      <item>
        <title>쿠버네티스(Kubernetes)</title>
        <description>&lt;p&gt;&lt;strong&gt;컨테이너 인프라 환경이란 리눅스 운영 체제의 커널 하나에서 여러 개의 컨테이너가 격리된 상태로 실행되는 인프라 환경을 말한다&lt;/strong&gt;. 여기서 컨테이너는 하나 이상의 목적을 위해 독립적으로 작동하는 프로세스를 뜻한다.&lt;/p&gt;

&lt;h2 id=&quot;컨테이너-오케스트레이션&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;컨테이너 오케스트레이션&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;실제로 쿠버네스트는 컨테이너 오케스트레이션을 위한 솔루션으로, &lt;strong&gt;오케스트레이션이란 복잡한 단계를 관리하고 요소들의 유기적인 관계를 미리 정의해 손쉽게 사용하도록 서비스를 제공하는 것을 뜻한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;다수의 컨테이너를 유기적으로 연결, 실행, 종료할 뿐만 아니라 상태를 추적하고 보존하는 등 컨테이너를 안정적으로 사용할 수 있게 만들어주는 것이 컨테이너 오케스트레이션이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;도커-스웜docker-swarm&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;도커 스웜(Docker Swarm)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;간단하게 설치할 수 있고 사용하기도 용이하다. 그러나 그만큼 기능이 다양하지 않아 대규모 환경에 적용하려면 사용자 환경을 변경해야 할 수 있다. 그리하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;소규모 환경에서는 유용하지만, 대규모 환경에서는 잘 사용하지 않는다.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;메소스mesos&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;메소스(Mesos)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;아파치의 오픈 소스 프로젝트로 역사와 전통이 있는 클러스터 도구이며 다양한 곳에서 충분히 검증된 솔루션이다. 메소스는 매우 간결하지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기능을 충분히 활용하려면 분산 관리 시스탬과 연동해야 하기 때문에 여러가지 솔루션을 유기적으로 구성해야 하는 부담이 있다.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;노매드nomad&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;노매드(Nomad)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;베어그런트를 만든 해시코프사의 컨테이너 오케스트레이션으로, 베이그런트처럼 간단한 구성으로 컨테이너 오케스트레이션 환경을 제공한다. 하지만 도커 스웜과 마찬가지로 기능이 부족하므로 복잡하게 여러 기능을 사용하는 환경이 아닌 가볍고 간단한 기능만 필요한 환경에서 사용하는 것이 좋다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;쿠버네티스kubernetes&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;쿠버네티스(Kubernetes)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;다른 오케스트레이션 솔루션보다는 시작하는 데 어려움이 있지만, 쉽게 사용할 수 있도록 도와주는 도구들이 있어서 설치가 쉬워지는 추세이다. 또 다양한 형태의 쿠버네티스가 지속적으로 계속 발전되고 있어 컨테이너 오케스트레이션을 넘어 IT 인프라 자체를 컨테이너화하고, 컨테이너화된 인프라 제품군을 쿠버네티스 위에서 동작할 수 있게 만든다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;컨테이너 오케스트레이션 솔루션 비교&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;도커 스윔&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;메소스&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;노매드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;쿠버네티스&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;설치 난이도&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용 편의성&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;세부 설정 지원&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;거의 없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;있음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;거의 없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;다양하게 있음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안정성&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 안정적임&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안정적임&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안정적엄&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 안정적임&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;확장성&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 잘 됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 잘 됨&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정보량&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;많음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 많음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;에코 파트너&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;거의 없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;있음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 많음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;학습 곡선&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;쿠버네티스-구성-방법&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;쿠버네티스 구성 방법&lt;/span&gt;&lt;/h6&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;퍼블릭 클라우드 업체에서 제공하는 &lt;strong&gt;관리형 쿠버네티스&lt;/strong&gt;인 EKS, AKS, GKE 등을 사용한다. 구성이 이미 갖춰져 있고 마스터 노드를 크라우드 업체에서 관리함으로 학습용으로는 부적합하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;수세의 Rancher, 레드햇의 OpenShift와 같은 플랫폼에서 제공하는 &lt;strong&gt;설치형 쿠버네티스&lt;/strong&gt;를 사용한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;허나 유료다.&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용하는 시스템에 쿠버네티스 클러스터를 &lt;strong&gt;자동으로 구성해주는 솔루션을 사용&lt;/strong&gt;한다. 주요 솔루션으로는 kubeadm, kops, KBIB, kubespray가 있다. 이 중 kubeadm이 가장 잘 알려져 있고, 사용자가 변경하기도 수월하며, 온프레미스와 클라우드를 모두 지원한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;쿠버네티스 클러스터 구성 솔루션 비교&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;도커 스윔&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;메소스&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;노매드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;쿠버네티스&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정보량&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;많음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;많음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 많음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;세부 설정 변경&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;가능함&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;가능함&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제한적으로 가능함&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;다양함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사전 요구 조건&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 적음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;온프레미스 지원&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라우드 지원&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안 됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;학습 곡선&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;자동화 기능&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제공됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제공됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽게 제공됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제한적으로 제공됨&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;파드를-배포할-때&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;파드를 배포할 때&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;쿠버네스트의 구성 요소의 유기적인 연결관계를 그림으로 표현하면 다음과 같다.&lt;br /&gt;
그림에 표시된 숫자는 실제로 관리자나 개발자가 파드 배포 명령을 수행했을 때 실행되는 순서다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes1.jpeg&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;h4 style=&quot;color:MediumSlateBlue&quot;&gt;마스터 노드&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;⓪. kubectl&lt;/strong&gt; : 쿠버네티스 클러스터에 명령을 내리는 역할을 한다. 다른 구성 요소들과 다르게 바로 실행되는 명령 형태인 바이너리(binary)로 배포되기 때문에 마스터 노드에 있을 필요는 없다. 허나, 통상적으로 API 서버와 주로 통신하므로 마스터 노드에 구성하였다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;①. API 서버&lt;/strong&gt; : 쿠버네티스 클러스터의 중심 역할을 하는 통로이다. 주로 상태 값을 저장하는 etcd와 통신하지만, 그 밖의 요소들 또한 API 서버를 중심에 두고 통신하므로 API 서버의 역할이 매우 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;②. etcd&lt;/strong&gt; : 구성 요소들의 상태 값이 모두 저장되는 곳이다. 회사의 관리자가 모든 보고 내용을 기록하는 노트라고 생각하면 된다. 실제로 etcd 외의 다른 구성 요소는 상태 값을 관리하지 않는다. 그러므로 etcd의 정보만 백업되어 있다면 장애 상황에서도 쿠버네티스 클러스터는 복구할 수 있다. 또한 etcd는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;분산 저장이 가능한 key-value 저장소&lt;/code&gt;이므로, 복제해 여러 곳에 저장해 두면 하나의 etcd에서 장애가 나더라도 시스템의 가용성을 확보할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;③. 컨트롤러 매니저&lt;/strong&gt; : 컨트롤러 매니저는 쿠버네티스 클러스터의 오브젝트 상태를 관리한다. 예를 들어 워커 노드에서 통신이 되지 않는 경우, 상태 체크와 복구는 컨트롤러 매니어제 속한 노드 컨트롤러에서 이뤄진다. 다양한 상태 값을 관리하는 주체들이 컨트롤러 매니저에 소속되어 각자의 역할을 수행한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;④. 스케줄러&lt;/strong&gt; : 노드의 상태와 자원, 레이블, 요구 조건 등을 고려해 파드를 어떤 워커 노드에 생성할 것인지를 결정하고 할당한다. 스케줄러라는 이름에 맞게 파드를 조건에 맞는 워커 노드에 지정하고, 파드가 워커 노드에 할당되는 일정을 관리한다.&lt;/p&gt;

&lt;h4 style=&quot;color:MediumSlateBlue&quot;&gt;워커 노드&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;⑤. kubelet&lt;/strong&gt; : 파드의 구성 내용(PodSpec)을 받아서 컨테이너 런타임으로 전달하고, 파드 안의 컨테이너들이 정상적으로 작동하는지 모니터링 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;⑥. 컨테이너 런타임(CRI)&lt;/strong&gt; : 파드를 이루는 컨테이너의 실행을 담당한다. 파드 안에서 다양한 종류의 컨테이너가 문제 없이 작동하게 만드는 표준 인터페이스이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;⑦. 파드(Pod)&lt;/strong&gt; : 한 개 이상의 컨테이너로 단일 목적의 일을 하기 위해서 모인 단위이다. 즉, 웹서버 역할을 할 수도 있고 로그나 데이터를 분석할 수도 있다. 중요한 것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;파드는 언제라도 죽을 수 있는 존재라는 점&lt;/code&gt;이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
조훈·심근우·문성주 (2021). 컨테이너 인프라 환경 구축을 위한 쿠버네티스/도커. 길벗&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/docker-kubernetes/kuberbetes/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/docker-kubernetes/kuberbetes/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>Docker-Kubernetes</category>
        
      </item>
    
      <item>
        <title>인프라 환경</title>
        <description>&lt;p&gt;컨테이너 인프라 환경은 컨테이너를 중심으로 구성된 인프라 환경이다. &lt;strong&gt;컨터이너(container)는 하나의 운영체제 커널에서 다른 프로세스에 영향을 받지 않고 독립적으로 실행되는 프로세스 상태를 의미&lt;/strong&gt;한다. 이렇게 구현된 컨테이너는 가상화 상태에서 동작하는 프로세스보다 가볍고 빠르게 동작한다.&lt;/p&gt;

&lt;h2 id=&quot;모놀리식-아키텍쳐monolithic-architecture&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;모놀리식 아키텍쳐(Monolithic Architecture)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;모놀리식 아키텍처는 하나의 큰 목적이 있는 서비스 또는 애플리케이션에 여러 기능이 통합돼 있는 구조를 의미&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;모놀리식 아키텍처에서는 소프트웨어가 하나의 결합된 코드로 구성되기 때문에 초기 단계에서 설계하기 쉽고 개발이 단순하고 코드관리가 간편하다는 장점이 있다.&lt;/p&gt;

&lt;p&gt;하지만 서비스를 운영 하다보면 자연스레 수정사항이 많아지게 되는데, 이때 한 서비스를 수정하면 연관된 다른 서비스에 영향을 끼칠 가능성이 커지게 된다. 점점 기능이 추가될수록 초기에 단순했던 서비스 관계는 매우 복잡해질 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;마이크로서비스-아키텍쳐msa-microservice-architecture&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;마이크로서비스 아키텍쳐(MSA, MicroService Architecture)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;마이크로서비스 아키텍쳐는 시스템 전체가 하나의 목적을 지향하는 바는 모놀리식 아키텍쳐와 동일하지만, 개별 기능의 작은 서비스를 각각 개발해 연결하는 데서 차이가 있다&lt;/strong&gt;. 보안, 인증 등과 관련된 기능이 독립된 서비스를 구성하고 있으며 다른 서비스들도 독립적으로 동작할 수 있는 완결된 구조이다.&lt;/p&gt;

&lt;p&gt;이런 구조로 개발된 서비스는 재사용하기 쉽고, 향후 서비스가 변경됐을 때 다른 서비스에 영향을 끼칠 가능성이 줄어들어 사용량의 변화에 따라 특정 서비스만 확장할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 마이크로서비스 아키텍쳐는 모놀리식 아키텍처보다 복잡도가 높고, 각 서비스가 서로 유기적으로 통신하는 구조로 설계되기 때문에 네트워크를 통한 호출 횟수가 증가해 성능에 영향을 줄 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;컨테이너-인프라-환경을-지원하는-도구&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;컨테이너 인프라 환경을 지원하는 도구&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;컨테이너 인프라 환경은 크게 &lt;strong&gt;컨테이너&lt;/strong&gt;, &lt;strong&gt;컨테이너 관리&lt;/strong&gt;, &lt;strong&gt;개발 환경 구성 및 배포 자동화&lt;/strong&gt;, &lt;strong&gt;모니터링&lt;/strong&gt;으로 구성되며, 이를 지원하는 도구는 아래와 같다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;도커docker&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;도커(Docker)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;도커는 컨테이너 환경에서 독립적으로 애플리케이션을 실행할 수 있도록 컨테이너를 만들고 관리하는 것을 도와주는 컨테이너 도구&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;도커로 애플리케이션을 실행하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;운영체제 환경에 상관없이 독립적인 환경에서 일관된 결과를 보장&lt;/code&gt;한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;쿠버네티스kubernetes&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;쿠버네티스(Kubernetes)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;쿠버네티스는 다수의 컨테이너를 관리하는 데 사용된다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;컨테이너의 자동 배포와 배포된 컨테이너에 대한 동작 보증, 부하에 따른 동적 확장 등의 기능을 제공한다. 처음엔 다수의 컨테이너만 관리하는 도구였으나, 현재는 컨테이너 인프라 필요한 기능을 통합하고 관리하는 솔루션으로 발전하였다.&lt;/p&gt;

&lt;p&gt;쿠버네티스는 컨테이너 인프라를 기반으로 API 게이트웨이, 서비스 디스커버리, 이벤트 버스, 인증 및 결제 등의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다양한 서비스를 효율적으로 관리할 수 있는 환경을 제공하고 이를 내외부와 유연하게 연결&lt;/code&gt;해준다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;젠킨스jenkins&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;젠킨스(Jenkins)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;젠킨스는 지속적 통합(CI, Continuous Integration)과 지속적 배포(CD, Continuous Deployment)를 지원한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;지속적 통합과 지속적 배포는 개발한 프로그램의 빌드, 테스트, 패키지화, 배포 단계를 모두 자동화해 개발 단계를 표준화한다. 개발된 코드의 빠른 적용과 효과적인 관리릍 통해 개발 생산성을 높이는 데 초점이 맞춰져있다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;컨테이너 인프라 환경처럼 단일 기능을 빠르게 개발해 적용해야 하는 환경에 매우 적합한 도구&lt;/code&gt;이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;프로메테우스prometheus와-그라파나grafana&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;프로메테우스(Prometheus)와 그라파나(Grafana)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;프로메테우스와 그라파나는 모니터링을 위한 도구이다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;프로메테우스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상태 데이터를 수집&lt;/code&gt;하고,&lt;br /&gt;
그라파나는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로메테우스로 수집한 데이터를 관리자가 보기 좋게 시각화&lt;/code&gt;한다.&lt;/p&gt;

&lt;p&gt;컨테이너 인프라 환경에서는 많은 종류의 소규모 기능이 각각 나뉘어 개발되기 때문에 중앙 모니터링이 필요한데, 이때 효율적으로 모니터링을 하는 방법 중 하나가 프로메테우스와 그라파나의 조합이다.&lt;/p&gt;

&lt;p&gt;프로메테우스와 그라파나는 컨테이너로 패키징되어 동작하며, 최소한의 자원으로 쿠버네티스 클러스터의 상태를 시각적으로 표현한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
조훈·심근우·문성주 (2021). 컨테이너 인프라 환경 구축을 위한 쿠버네티스/도커. 길벗&lt;/p&gt;

</description>
        <pubDate>Sun, 10 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/docker-kubernetes/infra/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/docker-kubernetes/infra/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>Docker-Kubernetes</category>
        
      </item>
    
      <item>
        <title>상태 코드</title>
        <description>&lt;p&gt;HTTP 상태 코드는 크게 다섯가지로 나뉘는데, 아래에서 자세히 살펴보자&lt;/p&gt;

&lt;h2 id=&quot;100-199-정보성-상태-코드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;100-199: 정보성 상태 코드&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;정보성 상태 코드는 HTTP/1.1에서 도입되었다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;사유 구절&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Continue&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지는 계속 이어서 보내야 함을 의미한다. 서버는 반드시 요청을 받아 응답해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;101&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Swiching Protocols&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;100 Contine는 HTTP 클라이언트 애플리케이션이 서버에 엔터티 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 하는데, 그 확인 작업을 최적화하기 위한 의도로 도입 된 것이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;클라이언트와 100 Continue&lt;/span&gt;&lt;br /&gt;
만약 클라이언트가 엔터티를 서버에게 보내려고 하고, 그 전에 100 Continue 응답을 기다리겠다면, 클라이언트는 값을 100-Continue로 하는 Expect 요청 헤더를 보낼 필요가 있다. 만약 클라이언트가 엔터티를 보내지 않으려 한다면, 100-Continue Expect 헤더를 보내지 않아야 한다.&lt;br /&gt;
100-Continue는 여러 측면에서 최적화를 위한 것이다. 클라이언트 애플리케이션은 100-Continue를 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않으려는 목적으로만 사용해야 한다. 이때, 100-Continue 값이 담긴 Expect 헤더를 보낸 클라이언트는 서버가 응답을 보내주기만을 막연히 기다리기만 하면 안 된다. 약간의 타임아웃 후에 클라이언트는 그냥 엔터티를 보내야 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;서버와 100 Continue&lt;/span&gt;&lt;br /&gt;
서버가 100-Continue 값이 담긴 Expect 헤더가 포함된 요청을 받는다면, 100-Continue 응답 혹은 에러 코드로 답해야 한다. 서버는 절대 100-Continue 응답을 받을 것을 의도하지 않은 클라이언트에게 보내서는 안 된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;200-299-성공-상태-코드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;200-299: 성공 상태 코드&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;클라이언트가 요청을 보내면, 그 요청을 대부분 성공한다. 서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;사유 구절&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;200&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;OK&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청은 정상이고, 엔터티 본문은 요청된 리소스를 포함하고 있다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;201&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Created&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버 개체를 생성하는 요청을 위한 것. 응답은 생성된 리소스에 대한 최대한 구체적인 참조가 담긴 Location 헤더와 함께, 그 리소스를 참조할 수 있는 여러 URL를 엔터티 본문에 포함해야 한다. 서버는 상태 코드를 보내기에 앞서 반드시 객체를 생성해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;202&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Accepted&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청은 받아들여졌으나 서버는 아직 그에 대한 어떤 동작도 수행하지 않았다. 서버가 요청의 처리를 완료할 것인지에 대한 어떤 보장도 없다. 이것은 단지 요청이 받아들이기에 적합해 보인다는 의미일 뿐이다. 서버는 엔터티 본문에 요청에 대한 상태와 가급적이면 요청의 처리가 언제 완료될 것인지에 대한 추정(혹은 그에 대한 정보를 어디서 얻을 수 있는지)도 포함해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;203&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Non-Authoritative Infomation&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다. 중개자가 리소스의 사본을 갖고 있었지만 리소스에 대한 메타 정보(헤더)를 검증하지 못한(혹은 안한) 경우 이런 일이 발생 할 수 있다. 이 응답 코드는 필수적으로 사용되어야 하는 것은 아니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;204&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;No Content&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;응답 메시지는 헤더와 상태줄을 포함하지만 엔터티 본문은 포함하지 않는다. 주로 웹브라우저를 새 문서로 이동시키지 않고 갱신하고자 할 때(예: 폼 리프레시) 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;205&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Reset Content&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;주로 브라우저를 위해 사용되는 또 하나의 코드. 브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 모든 값을 비우라고 말한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;206&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Partial Content&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;범위 요청이 성공했음을 의미한다. Content-Rage와 Data 헤더를 반드시 포함해야 하며, Etag와 Content-Location 중 하나의 헤더도 반드시 포함해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;300-399-리다이렉션-상태-코드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;300-399: 리다이렉션 상태 코드&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다. 만약 리소스가 옮겨졌다면, 클라이언트에게 리소스가 옮겨졌으며 어디서 찾을 수 있는 지 알려주기 위해 리다이렉션 상태코드와 선택적으로 Location 헤더를 보낼 수 있다.&lt;br /&gt;
리다이렉션 상태 코드 중 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;사유 구절&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;300&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Multiple Choices&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 그 리소스의 목록과 함께 반환된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;301&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Moved Pemanently&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청한 URL이 옮겨졌을 때 사용한다. 응답은 Location 헤더에 현재 리소스가 존재하고 있는 URL을 포함해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;302&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Found&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;301 상태 코드와 같다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다. 이후의 요청에서는 원래 URL을 사용해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;303&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;See Other&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 말해주고자 할 때 사용된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;304&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Not Modified&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트는 헤더를 이용해 조건부 요청을 만들 수 있다. 만약 클라리언트가 GET과 같은 조건부 요청을 보냈고, 그 요청한 리소스가 최근에 수정된 일이 없다면, 이 코드는 리소스가 수정되지 않았음을 의미하게 된다. 이 상태 코드를 동반한 응답은 엔터티 본문을 가져서는 안 된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;305&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Use Proxy&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;리소스가 반드시 프락시를 통해서 접근되어야 함을 나타내기 위해 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;306&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;(사용되지 않음)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;현재는 사용되지 않는다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;307&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Temporary Redirect&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;301 상태 코드와 비슷하다 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다. 이후의 요총에서는 원래 URL을 사용해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;400-499-클라이언트-에러-상태-코드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;400-499: 클라이언트 에러 상태 코드&lt;/span&gt;&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;사유 구절&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;400&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Bad Request&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트가 잘못된 요청을 보냈다고 말해준다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;401&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Unauthorized&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;리소스를 얻기 전에 클라리언트에게 스스로를 인증하라고 요구하는 내용의 응답을 적절한 헤더와 함께 반환한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;402&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Payment Required&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;현재 이 상태 코드는 쓰이지 않는다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;403&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Forbidden&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청이 서버에 의해 거부되었음을 알려주기 위해 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;404&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Not Found&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버가 요청한 URL을 찾을 수 없음을 알려주기 위해 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;405&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Method Not Allowed&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청한 URL에 대해, 지원하지 않는 메서드로 요청 받았을 때 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;406&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Not Acceptable&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트는 자신이 어떤 종류의 엔터티를 받아들이고자 하는지에 대해 매개변수로 명시할 수 있다. 이 코드는 주어진 URL에 대한 리소스 중 클라이언트가 받아들일 수 있는 것이 없는 경우 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;407&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Proxy Authentication Required&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;401 상태 코드와 같으나, 리소스에 대해 인증을 요구하는 프락시 서버를 위해 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;500-599-서버-에러-상태-코드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;500-599: 서버 에러 상태 코드&lt;/span&gt;&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;사유 구절&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;500&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Intenal Server Error&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;501&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Not Implemented&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트가 서버의 능력을 넘은 요청을 했을 때 사용한다.(예: 서버가 지원하지 않는 메서드 사용)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;502&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Bad Gateway&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;프락시나 게이트웨이처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다른 링크로부터 가짜 응답에 맞닥뜨렸을 때 사용한다.(예: 만약 자신의 부모 게이트웨이에 접속하는 것이 불가능할 때)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;503&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Service Unavailble&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;현재는 서버가 요청을 처리할 수 없지만, 나중에는 가능함을 의미하고자 할 때 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;504&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Gateway Timeout&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;상태 코드 408과 비슷하지만, 다른 서버에게 요청을 보내고 응답을 기다리다 타임아웃이 발생한 게이트웨이나 프락시에서 온 응답이라는 점이 다르다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;505&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HTTP Version Not Supported&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버가 지원할 수 없거나 지원하지 않으려고 하는 버전의 프로토콜로 된 요청을 받았을 때 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
데이빗 고울리·브라이언 토티·마조리 세이어·세일루 레디·안슈 아가왈. (2014). HTTP 완벽 가이드. 프로그래밍인사이트&lt;/p&gt;

</description>
        <pubDate>Sun, 26 Sep 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/http/status-code/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/http/status-code/</guid>
        
        <category>2021년 09월</category>
        
        
        <category>HTTP</category>
        
      </item>
    
  </channel>
</rss>