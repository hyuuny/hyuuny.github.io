<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  
  <channel>
    <title> Hyuuny`s Blog  </title>
    <description>객체지향과 DDD에 관심이 많은 백엔드개발자로서, 최근에는 리눅스와 도커에 관심이 생겨 함께 공부하고 있습니다.</description>
    <link>https://hyuuny.github.io/</link>
    <atom:link href="https://hyuuny.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 12 Oct 2021 22:12:50 +0900</pubDate>
    <lastBuildDate>Tue, 12 Oct 2021 22:12:50 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>쿠버네티스(Kubernetes)</title>
        <description>&lt;p&gt;&lt;strong&gt;컨테이너 인프라 환경이란 리눅스 운영 체제의 커널 하나에서 여러 개의 컨테이너가 격리된 상태로 실행되는 인프라 환경을 말한다&lt;/strong&gt;. 여기서 컨테이너는 하나 이상의 목적을 위해 독립적으로 작동하는 프로세스를 뜻한다.&lt;/p&gt;

&lt;h2 id=&quot;컨테이너-오케스트레이션&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;컨테이너 오케스트레이션&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;실제로 쿠버네스트는 컨테이너 오케스트레이션을 위한 솔루션으로, &lt;strong&gt;오케스트레이션이란 복잡한 단계를 관리하고 요소들의 유기적인 관계를 미리 정의해 손쉽게 사용하도록 서비스를 제공하는 것을 뜻한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;다수의 컨테이너를 유기적으로 연결, 실행, 종료할 뿐만 아니라 상태를 추적하고 보존하는 등 컨테이너를 안정적으로 사용할 수 있게 만들어주는 것이 컨테이너 오케스트레이션이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;도커-스웜docker-swarm&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;도커 스웜(Docker Swarm)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;간단하게 설치할 수 있고 사용하기도 용이하다. 그러나 그만큼 기능이 다양하지 않아 대규모 환경에 적용하려면 사용자 환경을 변경해야 할 수 있다. 그리하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;소규모 환경에서는 유용하지만, 대규모 환경에서는 잘 사용하지 않는다.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;메소스mesos&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;메소스(Mesos)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;아파치의 오픈 소스 프로젝트로 역사와 전통이 있는 클러스터 도구이며 다양한 곳에서 충분히 검증된 솔루션이다. 메소스는 매우 간결하지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기능을 충분히 활용하려면 분산 관리 시스탬과 연동해야 하기 때문에 여러가지 솔루션을 유기적으로 구성해야 하는 부담이 있다.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;노매드nomad&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;노매드(Nomad)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;베어그런트를 만든 해시코프사의 컨테이너 오케스트레이션으로, 베이그런트처럼 간단한 구성으로 컨테이너 오케스트레이션 환경을 제공한다. 하지만 도커 스웜과 마찬가지로 기능이 부족하므로 복잡하게 여러 기능을 사용하는 환경이 아닌 가볍고 간단한 기능만 필요한 환경에서 사용하는 것이 좋다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;쿠버네티스kubernetes&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;쿠버네티스(Kubernetes)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;다른 오케스트레이션 솔루션보다는 시작하는 데 어려움이 있지만, 쉽게 사용할 수 있도록 도와주는 도구들이 있어서 설치가 쉬워지는 추세이다. 또 다양한 형태의 쿠버네티스가 지속적으로 계속 발전되고 있어 컨테이너 오케스트레이션을 넘어 IT 인프라 자체를 컨테이너화하고, 컨테이너화된 인프라 제품군을 쿠버네티스 위에서 동작할 수 있게 만든다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;컨테이너 오케스트레이션 솔루션 비교&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;도커 스윔&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;메소스&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;노매드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;쿠버네티스&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;설치 난이도&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용 편의성&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;세부 설정 지원&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;거의 없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;있음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;거의 없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;다양하게 있음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안정성&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 안정적임&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안정적임&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안정적엄&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 안정적임&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;확장성&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 잘 됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 잘 됨&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정보량&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;많음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 많음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;에코 파트너&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;거의 없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;있음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 많음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;학습 곡선&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;쿠버네티스 클러스터 구성 솔루션 비교&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;도커 스윔&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;메소스&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;노매드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;쿠버네티스&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정보량&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;많음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;많음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 많음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;세부 설정 변경&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;가능함&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;가능함&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제한적으로 가능함&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;다양함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사전 요구 조건&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 적음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;온프레미스 지원&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라우드 지원&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안 됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;학습 곡선&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;자동화 기능&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제공됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제공됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽게 제공됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제한적으로 제공됨&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
조훈·심근우·문성주 (2021). 컨테이너 인프라 환경 구축을 위한 쿠버네티스/도커. 길벗&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/docker-kubernetes/kuberbetes/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/docker-kubernetes/kuberbetes/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>Docker-Kubernetes</category>
        
      </item>
    
      <item>
        <title>인프라 환경</title>
        <description>&lt;p&gt;컨테이너 인프라 환경은 컨테이너를 중심으로 구성된 인프라 환경이다. &lt;strong&gt;컨터이너(container)는 하나의 운영체제 커널에서 다른 프로세스에 영향을 받지 않고 독립적으로 실행되는 프로세스 상태를 의미&lt;/strong&gt;한다. 이렇게 구현된 컨테이너는 가상화 상태에서 동작하는 프로세스보다 가볍고 빠르게 동작한다.&lt;/p&gt;

&lt;h2 id=&quot;모놀리식-아키텍쳐monolithic-architecture&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;모놀리식 아키텍쳐(Monolithic Architecture)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;모놀리식 아키텍처는 하나의 큰 목적이 있는 서비스 또는 애플리케이션에 여러 기능이 통합돼 있는 구조를 의미&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;모놀리식 아키텍처에서는 소프트웨어가 하나의 결합된 코드로 구성되기 때문에 초기 단계에서 설계하기 쉽고 개발이 단순하고 코드관리가 간편하다는 장점이 있다.&lt;/p&gt;

&lt;p&gt;하지만 서비스를 운영 하다보면 자연스레 수정사항이 많아지게 되는데, 이때 한 서비스를 수정하면 연관된 다른 서비스에 영향을 끼칠 가능성이 커지게 된다. 점점 기능이 추가될수록 초기에 단순했던 서비스 관계는 매우 복잡해질 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;마이크로서비스-아키텍쳐msa-microservice-architecture&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;마이크로서비스 아키텍쳐(MSA, MicroService Architecture)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;마이크로서비스 아키텍쳐는 시스템 전체가 하나의 목적을 지향하는 바는 모놀리식 아키텍쳐와 동일하지만, 개별 기능의 작은 서비스를 각각 개발해 연결하는 데서 차이가 있다&lt;/strong&gt;. 보안, 인증 등과 관련된 기능이 독립된 서비스를 구성하고 있으며 다른 서비스들도 독립적으로 동작할 수 있는 완결된 구조이다.&lt;/p&gt;

&lt;p&gt;이런 구조로 개발된 서비스는 재사용하기 쉽고, 향후 서비스가 변경됐을 때 다른 서비스에 영향을 끼칠 가능성이 줄어들어 사용량의 변화에 따라 특정 서비스만 확장할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 마이크로서비스 아키텍쳐는 모놀리식 아키텍처보다 복잡도가 높고, 각 서비스가 서로 유기적으로 통신하는 구조로 설계되기 때문에 네트워크를 통한 호출 횟수가 증가해 성능에 영향을 줄 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;컨테이너-인프라-환경을-지원하는-도구&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;컨테이너 인프라 환경을 지원하는 도구&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;컨테이너 인프라 환경은 크게 &lt;strong&gt;컨테이너&lt;/strong&gt;, &lt;strong&gt;컨테이너 관리&lt;/strong&gt;, &lt;strong&gt;개발 환경 구성 및 배포 자동화&lt;/strong&gt;, &lt;strong&gt;모니터링&lt;/strong&gt;으로 구성되며, 이를 지원하는 도구는 아래와 같다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;도커docker&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;도커(Docker)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;도커는 컨테이너 환경에서 독립적으로 애플리케이션을 실행할 수 있도록 컨테이너를 만들고 관리하는 것을 도와주는 컨테이너 도구&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;도커로 애플리케이션을 실행하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;운영체제 환경에 상관없이 독립적인 환경에서 일관된 결과를 보장&lt;/code&gt;한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;쿠버네티스kubernetes&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;쿠버네티스(Kubernetes)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;쿠버네티스는 다수의 컨테이너를 관리하는 데 사용된다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;컨테이너의 자동 배포와 배포된 컨테이너에 대한 동작 보증, 부하에 따른 동적 확장 등의 기능을 제공한다. 처음엔 다수의 컨테이너만 관리하는 도구였으나, 현재는 컨테이너 인프라 필요한 기능을 통합하고 관리하는 솔루션으로 발전하였다.&lt;/p&gt;

&lt;p&gt;쿠버네티스는 컨테이너 인프라를 기반으로 API 게이트웨이, 서비스 디스커버리, 이벤트 버스, 인증 및 결제 등의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다양한 서비스를 효율적으로 관리할 수 있는 환경을 제공하고 이를 내외부와 유연하게 연결&lt;/code&gt;해준다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;젠킨스jenkins&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;젠킨스(Jenkins)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;젠킨스는 지속적 통합(CI, Continuous Integration)과 지속적 배포(CD, Continuous Deployment)를 지원한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;지속적 통합과 지속적 배포는 개발한 프로그램의 빌드, 테스트, 패키지화, 배포 단계를 모두 자동화해 개발 단계를 표준화한다. 개발된 코드의 빠른 적용과 효과적인 관리릍 통해 개발 생산성을 높이는 데 초점이 맞춰져있다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;컨테이너 인프라 환경처럼 단일 기능을 빠르게 개발해 적용해야 하는 환경에 매우 적합한 도구&lt;/code&gt;이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;프로메테우스prometheus와-그라파나grafana&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;프로메테우스(Prometheus)와 그라파나(Grafana)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;프로메테우스와 그라파나는 모니터링을 위한 도구이다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;프로메테우스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상태 데이터를 수집&lt;/code&gt;하고,&lt;br /&gt;
그라파나는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로메테우스로 수집한 데이터를 관리자가 보기 좋게 시각화&lt;/code&gt;한다.&lt;/p&gt;

&lt;p&gt;컨테이너 인프라 환경에서는 많은 종류의 소규모 기능이 각각 나뉘어 개발되기 때문에 중앙 모니터링이 필요한데, 이때 효율적으로 모니터링을 하는 방법 중 하나가 프로메테우스와 그라파나의 조합이다.&lt;/p&gt;

&lt;p&gt;프로메테우스와 그라파나는 컨테이너로 패키징되어 동작하며, 최소한의 자원으로 쿠버네티스 클러스터의 상태를 시각적으로 표현한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
조훈·심근우·문성주 (2021). 컨테이너 인프라 환경 구축을 위한 쿠버네티스/도커. 길벗&lt;/p&gt;

</description>
        <pubDate>Sun, 10 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/docker-kubernetes/infra/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/docker-kubernetes/infra/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>Docker-Kubernetes</category>
        
      </item>
    
      <item>
        <title>상태 코드</title>
        <description>&lt;p&gt;HTTP 상태 코드는 크게 다섯가지로 나뉘는데, 아래에서 자세히 살펴보자&lt;/p&gt;

&lt;h2 id=&quot;100-199-정보성-상태-코드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;100-199: 정보성 상태 코드&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;정보성 상태 코드는 HTTP/1.1에서 도입되었다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;사유 구절&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Continue&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지는 계속 이어서 보내야 함을 의미한다. 서버는 반드시 요청을 받아 응답해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;101&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Swiching Protocols&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;100 Contine는 HTTP 클라이언트 애플리케이션이 서버에 엔터티 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 하는데, 그 확인 작업을 최적화하기 위한 의도로 도입 된 것이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;클라이언트와 100 Continue&lt;/span&gt;&lt;br /&gt;
만약 클라이언트가 엔터티를 서버에게 보내려고 하고, 그 전에 100 Continue 응답을 기다리겠다면, 클라이언트는 값을 100-Continue로 하는 Expect 요청 헤더를 보낼 필요가 있다. 만약 클라이언트가 엔터티를 보내지 않으려 한다면, 100-Continue Expect 헤더를 보내지 않아야 한다.&lt;br /&gt;
100-Continue는 여러 측면에서 최적화를 위한 것이다. 클라이언트 애플리케이션은 100-Continue를 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않으려는 목적으로만 사용해야 한다. 이때, 100-Continue 값이 담긴 Expect 헤더를 보낸 클라이언트는 서버가 응답을 보내주기만을 막연히 기다리기만 하면 안 된다. 약간의 타임아웃 후에 클라이언트는 그냥 엔터티를 보내야 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;서버와 100 Continue&lt;/span&gt;&lt;br /&gt;
서버가 100-Continue 값이 담긴 Expect 헤더가 포함된 요청을 받는다면, 100-Continue 응답 혹은 에러 코드로 답해야 한다. 서버는 절대 100-Continue 응답을 받을 것을 의도하지 않은 클라이언트에게 보내서는 안 된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;200-299-성공-상태-코드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;200-299: 성공 상태 코드&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;클라이언트가 요청을 보내면, 그 요청을 대부분 성공한다. 서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;사유 구절&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;200&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;OK&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청은 정상이고, 엔터티 본문은 요청된 리소스를 포함하고 있다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;201&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Created&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버 개체를 생성하는 요청을 위한 것. 응답은 생성된 리소스에 대한 최대한 구체적인 참조가 담긴 Location 헤더와 함께, 그 리소스를 참조할 수 있는 여러 URL를 엔터티 본문에 포함해야 한다. 서버는 상태 코드를 보내기에 앞서 반드시 객체를 생성해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;202&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Accepted&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청은 받아들여졌으나 서버는 아직 그에 대한 어떤 동작도 수행하지 않았다. 서버가 요청의 처리를 완료할 것인지에 대한 어떤 보장도 없다. 이것은 단지 요청이 받아들이기에 적합해 보인다는 의미일 뿐이다. 서버는 엔터티 본문에 요청에 대한 상태와 가급적이면 요청의 처리가 언제 완료될 것인지에 대한 추정(혹은 그에 대한 정보를 어디서 얻을 수 있는지)도 포함해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;203&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Non-Authoritative Infomation&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다. 중개자가 리소스의 사본을 갖고 있었지만 리소스에 대한 메타 정보(헤더)를 검증하지 못한(혹은 안한) 경우 이런 일이 발생 할 수 있다. 이 응답 코드는 필수적으로 사용되어야 하는 것은 아니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;204&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;No Content&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;응답 메시지는 헤더와 상태줄을 포함하지만 엔터티 본문은 포함하지 않는다. 주로 웹브라우저를 새 문서로 이동시키지 않고 갱신하고자 할 때(예: 폼 리프레시) 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;205&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Reset Content&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;주로 브라우저를 위해 사용되는 또 하나의 코드. 브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 모든 값을 비우라고 말한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;206&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Partial Content&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;범위 요청이 성공했음을 의미한다. Content-Rage와 Data 헤더를 반드시 포함해야 하며, Etag와 Content-Location 중 하나의 헤더도 반드시 포함해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;300-399-리다이렉션-상태-코드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;300-399: 리다이렉션 상태 코드&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다. 만약 리소스가 옮겨졌다면, 클라이언트에게 리소스가 옮겨졌으며 어디서 찾을 수 있는 지 알려주기 위해 리다이렉션 상태코드와 선택적으로 Location 헤더를 보낼 수 있다.&lt;br /&gt;
리다이렉션 상태 코드 중 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;사유 구절&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;300&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Multiple Choices&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 그 리소스의 목록과 함께 반환된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;301&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Moved Pemanently&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청한 URL이 옮겨졌을 때 사용한다. 응답은 Location 헤더에 현재 리소스가 존재하고 있는 URL을 포함해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;302&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Found&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;301 상태 코드와 같다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다. 이후의 요청에서는 원래 URL을 사용해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;303&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;See Other&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 말해주고자 할 때 사용된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;304&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Not Modified&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트는 헤더를 이용해 조건부 요청을 만들 수 있다. 만약 클라리언트가 GET과 같은 조건부 요청을 보냈고, 그 요청한 리소스가 최근에 수정된 일이 없다면, 이 코드는 리소스가 수정되지 않았음을 의미하게 된다. 이 상태 코드를 동반한 응답은 엔터티 본문을 가져서는 안 된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;305&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Use Proxy&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;리소스가 반드시 프락시를 통해서 접근되어야 함을 나타내기 위해 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;306&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;(사용되지 않음)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;현재는 사용되지 않는다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;307&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Temporary Redirect&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;301 상태 코드와 비슷하다 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다. 이후의 요총에서는 원래 URL을 사용해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;400-499-클라이언트-에러-상태-코드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;400-499: 클라이언트 에러 상태 코드&lt;/span&gt;&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;사유 구절&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;400&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Bad Request&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트가 잘못된 요청을 보냈다고 말해준다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;401&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Unauthorized&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;리소스를 얻기 전에 클라리언트에게 스스로를 인증하라고 요구하는 내용의 응답을 적절한 헤더와 함께 반환한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;402&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Payment Required&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;현재 이 상태 코드는 쓰이지 않는다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;403&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Forbidden&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청이 서버에 의해 거부되었음을 알려주기 위해 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;404&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Not Found&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버가 요청한 URL을 찾을 수 없음을 알려주기 위해 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;405&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Method Not Allowed&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청한 URL에 대해, 지원하지 않는 메서드로 요청 받았을 때 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;406&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Not Acceptable&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트는 자신이 어떤 종류의 엔터티를 받아들이고자 하는지에 대해 매개변수로 명시할 수 있다. 이 코드는 주어진 URL에 대한 리소스 중 클라이언트가 받아들일 수 있는 것이 없는 경우 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;407&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Proxy Authentication Required&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;401 상태 코드와 같으나, 리소스에 대해 인증을 요구하는 프락시 서버를 위해 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;500-599-서버-에러-상태-코드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;500-599: 서버 에러 상태 코드&lt;/span&gt;&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;사유 구절&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;500&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Intenal Server Error&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;501&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Not Implemented&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트가 서버의 능력을 넘은 요청을 했을 때 사용한다.(예: 서버가 지원하지 않는 메서드 사용)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;502&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Bad Gateway&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;프락시나 게이트웨이처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다른 링크로부터 가짜 응답에 맞닥뜨렸을 때 사용한다.(예: 만약 자신의 부모 게이트웨이에 접속하는 것이 불가능할 때)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;503&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Service Unavailble&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;현재는 서버가 요청을 처리할 수 없지만, 나중에는 가능함을 의미하고자 할 때 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;504&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Gateway Timeout&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;상태 코드 408과 비슷하지만, 다른 서버에게 요청을 보내고 응답을 기다리다 타임아웃이 발생한 게이트웨이나 프락시에서 온 응답이라는 점이 다르다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;505&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HTTP Version Not Supported&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버가 지원할 수 없거나 지원하지 않으려고 하는 버전의 프로토콜로 된 요청을 받았을 때 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
데이빗 고울리·브라이언 토티·마조리 세이어·세일루 레디·안슈 아가왈. (2014). HTTP 완벽 가이드. 프로그래밍인사이트&lt;/p&gt;

</description>
        <pubDate>Sun, 26 Sep 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/http/status-code/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/http/status-code/</guid>
        
        <category>2021년 09월</category>
        
        
        <category>HTTP</category>
        
      </item>
    
      <item>
        <title>HTTP 메서드</title>
        <description>&lt;h2 id=&quot;안전한-메서드safe-method&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;안전한 메서드(Safe Method)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의한다. GET과 HEAD 메서드는 안전하다고 할 수 있는데, 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET이나 HEAD 메서드는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미&lt;/code&gt;한다.&lt;br /&gt;
안전한 메서드가 서버에 작용을 유발하지 않는 다는 보장은 없지만(웹 개발자가 어떻게 구현하냐에 달림), &lt;strong&gt;안전한 메서드의 목적은 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것에 있다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;예를 들면 구매하기 버튼을 눌렀을 때, POST 요청(신용카드 정보)이 서버로 전송 될텐데 이때 서버에서 신용카드로 결제될 수 있다는 경고 메시지를 띄우는 일이있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;get&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;GET&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;GET은 가장 흔히 사용되는 메서드&lt;/strong&gt;로서, 주로 서버에게 리소스를 달라고 요청하는데 사용된다. HTTP/1.1은 서버가 이 메서드를 구현할 것을 요구한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청 메시지
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET /seasonal/index.fall.html HTTP/1.1
Host: www.joes-hardware.com
Accept: *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;응답 메시지(엔터티 본문 포함)
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 200 OK
Content-type: text/html
Context-Length: 617
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;head&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;HEAD&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HEAD 메서드는 정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다&lt;/strong&gt;. 엔터티 본문은 반환되지 않고, 클라이언트가 리소스를 실제로 가져올 필요 없이 헤더만을 조사할 수 있도록 해준다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;리소스를 가져오지 않고도 그에 대해 무엇인가(타입)를 알아낼 수 있다.&lt;/li&gt;
  &lt;li&gt;응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.&lt;/li&gt;
  &lt;li&gt;헤더를 확인하여 리소스가 변경되었는지 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장&lt;/strong&gt;해야 하며, HTTP/1.1 준수를 위해서는 HEAD 메서드가 반드시 구현되어 있어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청 메시지
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HEAD /seasonal/index-fall.html HTTP/1.1
Host: www.joes-hardware.com
Accept: *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;응답 메시지(엔터티 본문 없음)
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 200 OK
Content-Type: text/html
Context-Length: 617
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;put&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;PUT&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;GET 메서드가 서버로부터 문서를 읽어들이는데 반해 PUT 메서드는 서버에 문서를 쓴다&lt;/strong&gt;. 어떤 발행 시스템은 사용자가 PUT을 이용해 웹페이지를 만들고 웹 서버에 직접 게시할 수 있도록 해준다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PUT 메서드의 의미는 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다&lt;/strong&gt;.&lt;br /&gt;
PUT은 컨텐츠를 변경할 수 있게 해주기 때문에, 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구하는 방식을 취한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청 메시지(서버는 ‘/product-list.txt’ 리소스를 갱신/생성하고 디스크에 저장한다.)
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUT /product-list.txt HTTP/1.1
Host: www.joes-hardware.com
Content-Type: text/plain
Content-length: 34
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;응답 메시지
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 201 Created
Location: http://www.joes-hardware.com/product-list.txt
Content-Type: text/plain
Content-Length: 47
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;post&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;POST&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계 되었다&lt;/strong&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PUT은 서버에 있는 리소스(예:파일)에 데이터를 입력하기 위해 사용된다면, POST는 서버에 데이터를 보내기 위해 사용&lt;/code&gt;&lt;br /&gt;
채워진 폼에 담긴 데이터는 서버로 전송되어 필요로 하는 곳(데이터를 처리할 서버 게이트웨이 프로그램 등)에 보낸다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청 메시지
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST /inventory-check.cgi HTTP/1.1
Host: www.joes-hardware.com
Content-Type: text/plain
Content-length: 18
item=bandsaw 2647(브라우저는 메시지의 엔터티 본문(body)에 데이터를 넣는다.)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;응답 메시지
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 200 OK
Content-type: text/plain
Context-length: 37
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;trace&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;TRACE&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과할 수 있다. &lt;strong&gt;TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;TRACE 요청은 목적지 서버에서 ‘루프백(loopback)’ 진단을 시작하는데, 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 돌려준다. 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메시지가 망가졌거나 수정되었는지, 만약 그렇다면 어떻게 변경되었는지 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;TRACE 메서드는 주로 진단을 위해 사용된다. 예를 들면 요청이 의도한 요청/응답 연쇄를 거쳐가는지 검사할 수 있고, 프락시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는지 확인해보고자 할 때도 좋은 도구다.&lt;/p&gt;

&lt;p&gt;TRACE는 진단을 위해 사용할 때는 괜찮지만, 메서드를 구별할 수는 없기 때문에 여러 다른 종류의 요청(GET, HEAD, POST 등 각각 다른 메서드를 사용한)들을 일관되게 다룬다는 문제가 있다. 많은 HTTP 애플리케이션은 메서드에 따라 다르게 동작하는데, TRACE 요청을 처리할 것인지에 대해서는 일반적으로 중간 애플리케이션이 결정을 내린다. 또 TRACE 요청은 어떠한 엔터티 본문도 보낼 수 없다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;options&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;OPTIONS&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다&lt;/strong&gt;. 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다(몇몇 서버는 특정 종류의 객체에 대해 특정 동작만을 지원).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청 메시지
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;OPTIONS * HTTP/1.1
Host: www.joes-hardware.com
Accept: *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;응답 메시지(OPTIONS 요청이 모든 리소스에 대한 것이므로, 서버는 자신의 리소스에 대해 지원하는 메서드의 목록을 반환하다.)
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 200 OK
Allow: GET, POST, PUT, OPTIONS(서버가 지원하는 메서드 목록 반환)
Context-length: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;delete&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;DELETE&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;DELETE 메서드는 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다&lt;/strong&gt;. 그러나 HTTP 명세는 서버가 클라이언트에게 알리지 않고, 요청을 무시하는 것을 허용하기 때문에 삭제가 수행되는 것을 보장하지 못한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청 메시지
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DELETE /product-list.txt HTTP/1.1
Host: www.joes-hardware.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;응답 메시지(파일 ‘product-list’가 서버에서 지워졌다.)
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 200 OK
Content-type: text/plain
Context-Length: 54
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;확장-메서드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;확장 메서드&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;확장 메서드는 HTTP/1.1 명세에 정의되지 않고, 개발자들에게 그들의 서버가 구현한 HTTP 서비스의 서버가 관리하는 리소스에 대한 능력을 확장하는 수단을 제공한다.&lt;/p&gt;

&lt;p&gt;확장 메서드의 대표적인 몇 가지는 아래 표와 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;메서드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;LOCK&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용자가 리소스를 잠글 수 있게 해준다. 예를 들어, 문서를 편집하는 동안 다른 사람이 동시에 같은 문서를 편집하지 못하도록 문서를 잠글 수 있다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MKCOL&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용자가 문서를 생성할 수 있게 해준다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;COPY&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버에 있는 리소스를 복사한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MOVE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버에 있는 리소스를 옮긴다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
데이빗 고울리·브라이언 토티·마조리 세이어·세일루 레디·안슈 아가왈. (2014). HTTP 완벽 가이드. 프로그래밍인사이트&lt;/p&gt;

</description>
        <pubDate>Wed, 22 Sep 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/http/method/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/http/method/</guid>
        
        <category>2021년 09월</category>
        
        
        <category>HTTP</category>
        
      </item>
    
      <item>
        <title>HTTP 메시지</title>
        <description>&lt;p&gt;HTTP가 인터넷의 배달원이라면, &lt;strong&gt;HTTP 메시지는 무언가를 담아 보내는 소포와 같다&lt;/strong&gt;.&lt;br /&gt;
이번에는 어떻게 메시지를 만들고 이해하는지에 대해 알아보자&lt;/p&gt;

&lt;h2 id=&quot;메시지의-흐름&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;메시지의 흐름&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다&lt;/strong&gt;. 이 데이터의 블록들은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 올 수 있다. 이 메시지는 클라이언트, 서버, 프락시 사이로 흐르며 ‘인바운드’, ‘아웃바운드’, ‘업스트림’, ‘다운스트림’은 메시지의 방향을 의미하는 용어다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;메시지는 원 서버 방향을 인바운드로 하여 송신된다.&lt;/span&gt;&lt;br /&gt;
HTTP는 &lt;strong&gt;트랜잭션 방향을 표현하기 위해 인바운드와 아웃바운드라는 표현을 사용&lt;/strong&gt;한다.&lt;br /&gt;
메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것이고, 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드로 이동하는 것이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;다운스트림으로 흐르는 메시지&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;요청 메시지냐 응답 메시지냐에 관계없이 모든 메시지는 다운스트림으로 흐른다&lt;/strong&gt;.&lt;br /&gt;
메시지의 발송자는 수신자의 업스트림이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;메시지의-각-부분&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;메시지의 각 부분&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HTTP 메시지는 단순한 데이터의 구조화된 블록이다&lt;/strong&gt;. 각 메시지는 클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함하며, 메시지는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시작줄, 헤더블록, 본문&lt;/code&gt; 이렇게 세 부분으로 이루어진다.&lt;/p&gt;

&lt;p&gt;시작줄은 이것이 어떤 메시지인지 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담거나 아예 없을 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;메시지 문법&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다&lt;/strong&gt;.&lt;br /&gt;
요청 메시지는 웹 서버에 어떤 동작을 요구하고, 응답 메시지는 요청의 결과를 클라이언트에게 돌려준다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청 메시지 형식&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;메서드&amp;gt;&amp;lt;요청URL&amp;gt;&amp;lt;버전&amp;gt;
&amp;lt;헤더&amp;gt;

&amp;lt;엔터티 본문&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;응답 메시지 형식&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;버전&amp;gt;&amp;lt;상태코드&amp;gt;&amp;lt;사유 구절&amp;gt;
&amp;lt;헤더&amp;gt;

&amp;lt;엔터티 본문&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;메서드&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;요청의 시작줄은 메서드로 시작하며, 클라이언트가 서버에게 무엇을 해야 하는지 말한다&lt;/strong&gt;.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;메서드 방식&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;메시지 본문(BODY) 여부&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버에서 어떤 문서를 가져온다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HEAD&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버에서 어떤 문서에 대해 헤더만 가져온다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;POST&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버가 처리해야 할 데이터를 보낸다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PUT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버에 요청 메시지의 본문을 저장한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TRACE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;OPTIONS&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버가 어떤 메서드를 수행할 수 있는지 확인한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DELETE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버에서 문서를 삭제한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;메서드에 대한 내용은 별도 포스팅에 다룰 예정.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;요청 URL&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소다&lt;/strong&gt;. 완전한 URL이 아닌 URL의 경로 구성요소라고 해도, 클라이언트가 서버와 직접 대화하고 있고 경로 구성요소가 리소스를 가리키는 절대 경로이기만 하면 대체로 문제가 없다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;상태 코드&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;상태코드는 클라이언트에게 요청 중에 무엇이 일어났는지 설명하는 세 자리 숫자다&lt;/strong&gt;.&lt;br /&gt;
상태 코드들은 세 자리 숫자로 된 그들의 코드 값을 기준으로 묶인다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;200에서 299까지의 상태 코드는 성공을 나타낸다.&lt;/li&gt;
  &lt;li&gt;300에서 399까지의 코드는 리소스가 옮겨졌음을 뜻한다.&lt;/li&gt;
  &lt;li&gt;400에서 499까지의 코드는 클라이언트가 뭔가 잘못된 요청을 했음을 의미한다.&lt;/li&gt;
  &lt;li&gt;500에서 599까지의 코드는 서버에서 뭔가 실패했음을 의미한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;사유 구절(reason-phrase)&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구로, 상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절이다&lt;/strong&gt;.&lt;br /&gt;
사유 구절은 오로지 사람에게 읽히기 위한 목적으로만 존재한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;헤더들&lt;/span&gt;&lt;br /&gt;
이름, 콜론(:), 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들, 이 헤더의 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시한다. HTTP/1.1과 같은 몇몇 버전의 HTTP는 요청이나 응답에 어떤 특정 헤더가 포함 되어야만 유효한 것으로 간주한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;엔터티 본문&lt;/span&gt;&lt;br /&gt;
엔터티 본문은 임의의 데이터 블록을 포함한다. 모든 메시지가 엔터티 본문을 갖는 것은 아니므로, 때때로 메시지는 그냥 CRLF으로 끝나게 된다. 헤더나 엔터티 본문이 없더라도 HTTP 헤더의 집합은 항상 빈 줄(CRLF)로 끝나야한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;시작줄&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;시작줄&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;모든 HTTP 메시지는 시작줄로 시작한다&lt;/strong&gt;.&lt;br /&gt;
요청 메시지의 시작줄은 무엇을 해야 하는지 말해주며, 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;요청줄&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;요청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁한다&lt;/strong&gt;. 요청 메시지의 시작줄 또는 요청줄에는 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대하 대상을 지칭하는 요청 URL이 들어 있다. 또한 요청줄은 클라이언트가 어떤 HTTP 버전인지 서버에게 알려주는 HTTP 버전도 포함한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;응답줄&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다&lt;/strong&gt;. 응답 메시지의 시작줄 또는 응답줄에는 응답 메시지에서 쓰인 HTTP의 버전, 숫자로 된 상태 코드, 수행 상태에 대해 설명해주는 텍스트로 된 사유구절이 포함된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
데이빗 고울리·브라이언 토티·마조리 세이어·세일루 레디·안슈 아가왈. (2014). HTTP 완벽 가이드. 프로그래밍인사이트&lt;/p&gt;

</description>
        <pubDate>Tue, 21 Sep 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/http/message/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/http/message/</guid>
        
        <category>2021년 09월</category>
        
        
        <category>HTTP</category>
        
      </item>
    
      <item>
        <title>URL과 리소스</title>
        <description>&lt;p&gt;&lt;strong&gt;URL은 브라우저가 정보를 찾는데 필요한 리소스의 위치를 가리키며&lt;/strong&gt;, URL을 이용해 사람과 애플리케이션이 인터넷상의 수십억 개의 리소스를 찾고 사용하며 공유할 수 있다. 그리고 URL을 통해 사람이 HTTP 및 다른 프로토콜을 통해 접근할 수 있다. &lt;strong&gt;사용자는 브라우저에 URL을 입력하고 브라우저는 화면 뒤에서 사용자가 원하는 리소스를 얻기 위해서 적절한 프로토콜을 사용하여 메시지를 전송&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;URL은 통합 자원 식별자(Uniform Resource Identifier) 혹은 URI라고 불리는 더 일반화된 부류의 부분집합&lt;/strong&gt;이다. URI는 두 가지 주요 부분집합인, URL과 URN으로 구성된 종합적인 개념이다. URN은 현재 그 리소스가 어디에 존재하든 상관없이 그 이름만으로 리소스를 식별하는데 비해 URL은 리소스가 어디 있는지 설명해서 리소스를 식별한다.&lt;/p&gt;

&lt;p&gt;HTTP 명세에서는 URI를 더 일반화된 개념의 리소스 식별자로 사용한다. 허나 실제로 HTTP 애플리케이션은 URL을 URI의 한 부분으로 취급한다.&lt;/p&gt;

&lt;p&gt;예를 들어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://www.joes-hardware.com/seasonal/index-fail.html&lt;/code&gt;이라는 URL을 불러온다하면&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;URL의 &lt;strong&gt;첫 부분인 http는 URL의 스킴이다&lt;/strong&gt;. 스킴은 웹 클라이언트가 리소스에 어떻게 접근하는지 나타낸다. 이 경우에는 URL이 HTTP 프로토콜을 사용한다는 것을 알 수 있다.&lt;/li&gt;
  &lt;li&gt;URL의 &lt;strong&gt;두 번째 부분인&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;www.joes-hardware.com&lt;/code&gt;&lt;strong&gt;은 서버의 위치다&lt;/strong&gt;. 이는 웹 클라이언트가 리소스가 어디에 호스팅 되어 있는지 나타낸다.&lt;/li&gt;
  &lt;li&gt;URL의 &lt;strong&gt;세 번째 부분인&lt;/strong&gt; &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;/seasonal/index-fail.html&lt;/code&gt;&lt;strong&gt;은 리소스의 경로다&lt;/strong&gt;. 경로는 서버에 존재하는 로컬 리소스들 중에서 요청받은 리소스가 무엇인지 나타낸다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;URL은 HTTP 프로토콜이 아닌 다른 프로토콜을 사용할 수도 있다.
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;mailto:president@whitehouse.gov&lt;/code&gt;는 이메일 주소를 가리키며,&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;ftp://ftp.lots-o-books.com/pub/comlite-price-list.xls&lt;/code&gt;는 FTP 서버에 올라가 있는 파일을 가리킨다.&lt;/p&gt;

&lt;p&gt;대부분의 URL은 동일하게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;스킴://서버위치/경로&lt;/code&gt; 구조로 이루어져 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;url-문법&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;URL 문법&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;URL로 인터넷상의 모든 리소스를 찾을 수 있지만, 그 리소스들은 스킴(HTTP, FTP, SMTP)을 통해 접근할 수 있으며, URL 문법은 스킴에 따라서 달라진다.&lt;/p&gt;

&lt;p&gt;대부분의 URL 스킴의 문법은 일반적으로 9개의 부분으로 나뉜다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;스킴&amp;gt;://&amp;lt;사용자이름&amp;gt;:&amp;lt;비밀번호&amp;gt;@&amp;lt;호스트&amp;gt;:&amp;lt;포트&amp;gt;/&amp;lt;경로&amp;gt;;&amp;lt;파라미터&amp;gt;?&amp;lt;질의&amp;gt;#&amp;lt;프래그먼트&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;이처럼 모든 컴포넌트를 갖는 URL은 거의 없고, &lt;strong&gt;URL의 가장 중요한 세 가지 컴포넌트는 스킴, 호스트, 경로다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;아래는 URL 컴포넌트에 대한 도표이다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;컴포넌트&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;기본값&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;스킴&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;리소스를 가져오려면 어떤 프로토콜을 사용하여 서버에 접근해야 하는지 가리킨다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;없음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용자 이름&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;몇몇 스킴은 리소스에 접근을 하기 위해 사용자 이름을 필요로 한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;anonymous&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;비밀번호&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용자의 비밀번호를 가리키며, 사용자 이름에 콜론(:)으로 이어서 기술한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;이메일 주소&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;호스트&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;리소스를 호스팅하는 서버의 호스트 명이나 IP 주소.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;없음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;포트&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;리소스를 호스팅하는 서버가 열어놓은 포트번호, 많은 스킵이 기본 포트를 가지고 있다.(HTTP 기본 포트는 80)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;스킴에 따라 다름&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;경로&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;이전 컴포넌트와 빗금(/)으로 구분되어 있으며, 서버 내 리소스가 서버 어디에 있는지를 가리킨다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;없음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;파라미터&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;특정 스킴들에서 입력 파라미터를 기술하는 용도로 사용한다. 파라미터는 이름/값 쌍으로 가지며, 다른 파라미터나 경로의 일부와 세미콜론(;)으로 구분하여 기술하고, 여러 개를 가질 수 있다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;없음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;질의&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;스킴에서 애플리케이션(DB, 게시판, 검색엔진, 기타 인터넷 게이트웨이)에 파라미터를 전달하는데 쓰인다. URL 끝에 “?”로 구분한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;없음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;프래그먼트&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;리소스의 조각이나 일부분을 가리키는 이름이다. URL의 끝에서 “#”문자로 구분한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;없음&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;스킴:사용할 프로토콜&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;스킴은 주어진 리소스에 어떻게 접근하는지 알려주는 중요한 정보다&lt;/strong&gt;.&lt;br /&gt;
URL을 해석하는 애플리케이션이 어떤 프로토콜을 사용하여 리소스를 요청해야 하는지 알려주는데, 스킴 컴포넌트는 알파벳으로 시작해야 하고 URL의 나머지 부분들과 첫 번째 ‘:’ 문자로 구분한다.&lt;br /&gt;
스킴 명은 대소문자를 구분하지 않으므로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://www.joes-hardware.com&lt;/code&gt;이나 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;HTTP://www.joes-hardware.com&lt;/code&gt;는 같다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;호스트와 포트&lt;/span&gt;&lt;br /&gt;
애플리케이션이 인터넷에 있는 리소스를 찾으려면, 리소스를 호스팅하고 있는 장비와 그 장비 내에서 리소스에 접근할 수 있는 서버가 어디에 있는지 알아야 한다. URL의 호스트와 포트 컴포넌트는 그 두 가지 정보를 제공해준다.&lt;/p&gt;

&lt;p&gt;예를 들어 아래 두 개의 URL은 같은 리소스를 가리킨다.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://www.joes-hardware.com:80/index.html&lt;/code&gt; (호스트 명으로 가리킴)
&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://161.58.228.45:80/index.html&lt;/code&gt; (IP 주소로 가리킴)&lt;br /&gt;
&lt;br /&gt;
포트 컴포넌트는 서버가 열어놓은 네트워크 포트를 가리키며, 내부적으로 TCP 프로토콜을 사용하는 HTTP는 기본 폰트로 80을 사용한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;경로&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;URL의 경로 컴포넌트는 리소스가 서버의 어디에 있는지 알려준다&lt;/strong&gt;.&lt;br /&gt;
&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://www.joes-hardware.com:80/seasonal/index-fail.html&lt;/code&gt;이라는 URL 경로는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;seasonal/index-fail.html&lt;/code&gt;로 유닉스 파일 시스템의 파일 경로와 유사하다. 경로는 서버가 리소스의 위치를 찾는데 사용하는 정보로 HTTP URL에서 경로 컴포넌트는 ‘/’문자를 기준으로 나뉜다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;상대-url&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;상대 URL&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;URL은 상대 URL과 절대 URL 두 가지로 나뉜다&lt;/strong&gt;. 절대 URL은 리소스에 접근하는데 필요한 모든 정보를 가지고 있다. 그와 달리 상대 URL은 모든 정보를 담고 있지는 않다. 상대 URL로 리소스에 접근하는데 필요한 모든 정보를 얻기 위해서는 기저(base)라고 하는 다른 URL을 사용해야 한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;스킴&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;스킴&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;웹에서 쓰이는 유명한 스킴들의 포맷은 아래와 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;스킴&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;http&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용자 이름이나 비밀번호가 없다는 것을 제외하고는, 일반 URL 포맷을 지키는 하이퍼텍스트 전송 프로토콜(Hyper Text Transfer Protocol)스킴이다.&lt;br /&gt; 포트값이 생략되어 있으면 기본값은 80이다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;https&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;https 스킴은 http 스킴과 거의 같다. 다른 점이라고는 https는 HTTP의 커넥션의 양 끝단에서 암호화하기 위해 넷스케이프에서 개발한 보안 소켓 계층(Secure Sockets Layer, SSL)을 사용한다는 것이다.&lt;br /&gt; 문법은 HTTP와 같고 기본 포트값은 443이다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;mailto&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;mailto URL은 이메일 주소를 가리킨다. 이메일은 다른 스킴과는 다르게 동작하기 때문에, mailto URL은 표준 URL과는 다른 포맷을 가진다. 인터넷 이메일 주소의 문법은 RFC 822에 기술되어 있다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ftp&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;파일 전송 프로토콜(File Transfer Protocol) URL은 FTP 서버에 있는 파일을 내려 받거나 올리고, FTP 서버의 디렉터리에 있는 컨텐츠 목록을 가져오는데 사용할 수 있다.&lt;br /&gt; FTP는 웹과 URL이 출현하기 전부터 있었다. 웹 애플리케이션은 데이터에 접근하는 용도의 스킴으로 FTP를 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;rtsp, rtspu&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RTSP URL은 실시간 스트리밍 프로토콜(Real Time Streaming Protocol)을 통해서 읽을 수 있는 오디오 및 비디오와 같은 미디어 리소스 식별자다.&lt;br /&gt; rtspu 스킴에 있는 ‘u’는 리소스를 읽기 위해서 UDP 프로토콜이 사용됨을 뜻한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;file&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;file 스킴은 주어진 호스트 기기(로컬 디스크, 네트워크 파일 시스템 혹은 기타 파일 공유 시스템)에서 바로 접근할 수 있는 파일들을 나타낸다. 각 필드도 일반적인 URL 포맷을 따른다. 만약 호스트가 생략되어 있으면, URL울 사용하고 있는 기기의 로컬 호스트가 기본값이 된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;telnet&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;telnet 스킴은 대화형 서비스에 접근하는데 사용한다. telnet URL 자체가 객체를 가리키지는 않지만, 리소스라고 할 수 있는 대화형 애플리케이션은 이 telnet 프로토콜을 통해 접근할 수 있다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
데이빗 고울리·브라이언 토티·마조리 세이어·세일루 레디·안슈 아가왈. (2014). HTTP 완벽 가이드. 프로그래밍인사이트&lt;/p&gt;
</description>
        <pubDate>Sun, 19 Sep 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/http/url-and-resource/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/http/url-and-resource/</guid>
        
        <category>2021년 09월</category>
        
        
        <category>HTTP</category>
        
      </item>
    
      <item>
        <title>HTTP</title>
        <description>&lt;p&gt;월드 와이드 웹을 지탱하는 가장 중요한 기술 &lt;strong&gt;두 가지는 HTML과 HTTP&lt;/strong&gt;이다. 이 두 기술은 팀 버너스 리가 웹을 발명할 때 함께 만들어졌다. 전 세계의 &lt;strong&gt;웹 브라우저, 서버, 웹 애플리케이션은 모두 HTTP(Hyper Text Tranfer Protocol)&lt;/strong&gt;를 통해 서로 대화한다.&lt;/p&gt;

&lt;h2 id=&quot;인터넷의-멀티미디어-배달부&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;인터넷의 멀티미디어 배달부&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;수십억 개의 JPEG 이미지, HTML 페이지, 텍스트 파일, MPEG 동영상, WAV 음성 파일, 자바 애플릿 등이 인터넷을 항해한다. HTTP는 전 세계의 웹 서버로부터 이 대량의 정보를 빠르고, 간편하고, 정확하게 웹 브라우저로 옮겨준다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;HTTP는 신뢰성 있는 데이터를 전송 프로토콜을 사용&lt;/strong&gt;하게 때문에, 데이터가 지구 반대편에서 오더라도 전송 중 손상되거나 꼬이지 않음을 보장한다. 그 덕분에 개발자는 인터넷의 결합이나 약점에 대한 걱정 없이 애플리케이션 고유의 기능을 구현하는데 집중할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;웹-클라이언트와-서버&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;웹 클라이언트와 서버&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;웹 컨텐츠는 웹 서버에 존재한다.&lt;br /&gt;
&lt;strong&gt;웹 서버는 HTTP 프로토콜로 의사소통하기 때문에 보통 HTTP 서버라고 불리며, 인터넷의 데이터를 저장하고, HTTP 클라이언트가 요청한 데이터를 제공&lt;/strong&gt;한다.&lt;br /&gt;
클라이언트는 서버에게 HTTP 요청을 보내고 서버는 요청된 데이터를 HTTP 응답으로 돌려주는데 예를 들어 “http://www.oreilly.com/index.html”페이지를 요청한다했을 때 이 과정은 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;웹 브라우저는 HTTP 요청을 www.oreilly.com 서버로 보낸다.&lt;/li&gt;
  &lt;li&gt;서버는 요청받은 객체(이 경우 “/index.html”)를 찾아 성공했다면 그것의 타입, 길이 등의 정보와 함꼐 HTTP 응답에 실어서 클라이언트에게 보낸다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;리소스&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;리소스&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;웹 서버는 웹 리소스를 관리하고 제공한다.&lt;br /&gt;
웹 리소스는 웹 컨텐츠의 원천으로 가장 단순한 웹 리소스는 웹 서버 파일 시스템의 정적 파일이다. 정적 파일은 텍스트 파일, HTML 파일, 마이크로소츠트 워드 파일, 어도비 아크로뱃파일, JPEG 이미지 파일 외 모든 종류의 파일을 포함한다. &lt;br /&gt;
그러나 &lt;strong&gt;리소스는 반드시 정적 파일이어야 할 필요는 없다&lt;/strong&gt;. 리소스는 카메라에서 라이브 영상을 가져와 보여주거나, 주식 거래, 부동산 데이터베이스 등 요청에 따라 컨텐츠를 생산하는 프로그램이 될수도 있다.&lt;br /&gt;
결국 &lt;strong&gt;어떤 종류의 컨텐츠 소스도 리소스가 될 수 있다.&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;미디어 타입&lt;/span&gt;&lt;br /&gt;
HTTP는 웹에서 전송되는 객체 각각에 MIME타입이라는 데이터 포맷 라벨을 붙인다.&lt;br /&gt;
MIME(Multipurpose Internet Mail Extensions)은 원래 각기 다른 전자메일 시스템 사이에서 메시지가 오갈 때 겪는 문제점을 해결하기 위해 설계되었는데, 이메일에서 워낙 잘 동작했기 때문에 HTTP에서도 멀티미디어 컨첸츠를 기술하고 라벨을 붙이기 위해 채택되었다.&lt;br /&gt;
&lt;strong&gt;웹 서버는 모든 HTTP 객체 데이터에 MIME 타입을 붙인다&lt;/strong&gt;. MIME 타입은 사선(/)으로 구분된 주 타입(primary object type)과 부 타입(specific subtype)으로 이루어진 문자열 라벨로 예를 들면 아래와 같다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;HTML로 작성된 텍스트 문서는 text/html 라벨이 붙는다.&lt;/li&gt;
  &lt;li&gt;plain ASCII 텍스트 문서는 text/plain 라벨이 붙는다.&lt;/li&gt;
  &lt;li&gt;JPEG 이미지는 image/jpeg가 붙는다.&lt;/li&gt;
  &lt;li&gt;GIF 이미지는 image/gif가 된다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;URI&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;서버 리소스 이름은 통합 자원 식별자(uniform resource identifier), 혹은 URL로 불린다.&lt;/strong&gt; URL는 인터넷의 우편물 주소 같은 것으로, &lt;strong&gt;정보 리소스를 고유하게 식별하고 위치를 지정&lt;/strong&gt;할 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;URL&lt;/span&gt;&lt;br /&gt;
통합 자원 지시자(uniform resource locator, URL)는 리소스 식별자의 가장 흔한 형태다. &lt;strong&gt;URL은 특정 서버의 한 리소스에 대한 구체적인 위치를 서술&lt;/strong&gt;한다. URL은 리소스가 정확히 어디에 있고 어떻게 접근할 수 있는지 분명히 알려준다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;URL&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;http://www.oreilly.com/index.html&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;오라일리 출판사 홈페이지의 URL&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;http://www.yahoo.com/images/logo.gif&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;야후! 웹사이트 로고의 URL&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;대부분의 URL은 세 부분으로 이루어진 표준 포멧을 따른다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;URL의 첫 번째 부분은 스킴(scheme)이라고 불리는데, 리소스에 접근하기 위해 사용되는 프로토콜을 서술한다. 보통 HTTP 프로토콜(http://)이다.&lt;/li&gt;
  &lt;li&gt;두 번째 부분은 서버의 인터넷 주소를 제공한다.(예:www.joes-hardware.com)&lt;/li&gt;
  &lt;li&gt;마지막 세 번째 부분은 웹 서버의 리소스를 가리킨다.(예:/specials/save-blade.gif)&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;트랜잭션&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;트랜잭션&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HTTP 트랜잭션은 요청 명령(클라이언트에서 서버로 보내는)과 응답 결과(서버가 클라이언트에게 돌려주는)로 구성&lt;/strong&gt;되어 있다.&lt;br /&gt;
이 상호작용은 HTTP 메시지라고 불리는 정형화된 데이터 덩어리를 이용해 이루어진다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;메서드&lt;/span&gt;&lt;br /&gt;
HTTP는 HTTP 메서드라고 불리는 여러가지 종류의 요청 명령을 지원하는데, 모든 &lt;strong&gt;HTTP 요청 메시지는 한 개의 메서드를 갖는다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;흔히 사용되는 HTTP 메서드는 아래와 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;HTTP 메서드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버에서 클라이언트로 지정한 리소스를 보내라.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PUT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트에서 서버로 보낸 데이터를 지정한 이름의 리소스로 저장하라.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DELETE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;지정한 리소스를 서버에서 삭제하라.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;POST&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트 데이터를 서버 게이트웨이 애플리케이션으로 보내라.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HEAD&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;지정한 리소스에 대한 응답에서, HTTP 헤더 부분만 보내라.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;상태 코드&lt;/span&gt;&lt;br /&gt;
모든 HTTP 응답 메시지는 상태 코드와 함께 반환된다.&lt;br /&gt;
&lt;strong&gt;상태코드는 클라이언트에게 요청이 성공했는지 아니면 추가 조치가 필요한지 알려주는 세자리 숫자&lt;/strong&gt;다.&lt;/p&gt;

&lt;p&gt;흔히 사용되는 상태코드는 아래와 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;HTTP 상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;200&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋다. 문서가 바르게 반환되었다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;302&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;다시 보내라. 다른 곳에 가서 리소스를 가져가라.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;404&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;없음. 리소스를 찾을 수 없다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;
HTTP는 각 숫자 상태 코드에 텍스트로 된 “사유 구절(reason phrase)”도 함께 보낸다.&lt;br /&gt;
이 구문은 단지 설명만을 위해서 포함된 것일 뿐 실제 응답 처리에는 숫자로 된 코드가 사용된다.&lt;br /&gt;
HTTP 소프트웨어는 다음에 열거된 상태 코드와 사유 구절을 모두 같은 것으로 취급한다.&lt;/p&gt;
&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;200 OK
200 Document attached
200 Success
200 All's cool, dude
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;웹 페이지는 여러 객체로 이루어질 수 있다.&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;애플리케이션은 보통 하나의 작업을 수행하기 위해 여러 HTTP 트랜잭션을 수행&lt;/strong&gt;한다.&lt;br /&gt;
예를 들어 웹브라우저는 시각적으로 풍부한 웹페이지를 가져올 때 대량의 HTTP 트랜잭션을 수행한다. 페이지 레이아웃을 서술하는 HTML “뼈대”를 한 번의 트랜잭션으로 가져온 뒤, 거기에 첨부된 이미지, 그래픽 조각, 자바 애플릿 등을 가져오기 위해 추가로 HTTP 트랜잭션을 수행한다. 이 리소스들은 서로 다른 서버에 각각 위치할 수도 있다. 이와 같이 &lt;strong&gt;웹페이지는 보통 하나의 리소스가 아닌 리소스의 모음&lt;/strong&gt;이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;메시지&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;메시지&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;HTTP 메시지는 &lt;strong&gt;단순한 줄 단위의 문자열&lt;/strong&gt;이다. 이진 형식이 아닌 일반 텍스트이기 때문에 사람이 읽고 쓰기 쉽다. 웹 클라이언트에서 웹 서버로 보낸 HTTP 메시지를 요청 메시지라고 부르고, 서버에서 클라이언트로 가는 메시지는 응답 메시지라고 부른다. 그 외에 다른 종류의 HTTP 메시지는 없다.&lt;/p&gt;

&lt;p&gt;HTTP 메시지는 다음의 세부분으로 이루어진다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;시작줄&lt;/span&gt;&lt;br /&gt;
메시지의 첫 줄은 시작줄로, 요청이라면 무엇을 해야 하는지 응답이라면 무슨일이 일어났는지 나타낸다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;헤더&lt;/span&gt;&lt;br /&gt;
시작줄 다음에는 0개 이상의 헤더 필드가 이어진다. 각 헤더 필드는 구문분석을 위해 &lt;strong&gt;쌍점(:)으로 구성되어 있는 하나의 이름과 하나의 값으로 구성&lt;/strong&gt;되며, 헤더는 빈 줄로 끝난다.
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;본문&lt;/span&gt;&lt;br /&gt;
빈 줄 다음에는 어떤 종류의 데이터든 들어갈 수 있는 메시지 본문이 필요에 따라 올 수 있다.&lt;br /&gt;
&lt;strong&gt;요청이 본문의 웹 서버로 데이터를 실어 보내며, 응답의 본문은 클라이언트로 데이터를 반환한다&lt;/strong&gt;.&lt;br /&gt;
시작줄이나 헤더와는 달리, 본문은 임의의 이진 데이터(이미지, 비디오, 오디오 트랙, 응용 소프트웨어)를 포함할 수 있다.
&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;tcpip&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;TCP/IP&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HTTP는 애플리케이션 계층 프로토콜&lt;/strong&gt;이다.&lt;br /&gt;
HTTP는 네트워크 통신의 핵심적인 세부사항에 대해서는 신경쓰지 않는다. 대신 대중적이고 신뢰성 있는 인터넷 전송 프로토콜인 TCP/IP에게 맡긴다.&lt;br /&gt;
&lt;strong&gt;TCP/IP는 TCP와 IP가 층을 이루는, 패킷 교환 네트워크 프로토콜의 집합&lt;/strong&gt;이다. TCP/IP는 각 네트워크와 하드웨어의 특성을 숨기고, 어떤 종류의 컴퓨터나 네트워크든 서로 신뢰성 있는 의사소통을 하게 해준다.&lt;br /&gt;
일단 TCP 커넥션이 맺어지면, 클라이언트와 서버 컴퓨터 간에 교환되는 메시지가 없어지거나, 손상되거나, 순서가 뒤바뀌는 일은 결코 없다.&lt;/p&gt;

&lt;p&gt;TCP는 다음을 제공한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;오류 없는 데이터 전송&lt;/li&gt;
  &lt;li&gt;순서에 맞는 전달(데이터는 언제나 보낸 순서대로 도착한다.)&lt;/li&gt;
  &lt;li&gt;조각나지 않는 데이터 스트림(언제든 어떤 크기로든 보낼 수 있다)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;span style=&quot;color:DodgerBlue&quot;&gt;IP 주소 그리고 포트번호&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;HTTP 클라이언트가 서버와 메시지를 전송할 수 있게 되기 전에 인터넷 프로토콜(Internet Protocol, IP) 주소와 포트번호를 사용해 클라이언트와 서버 사이에 TCP/IP 커넥션을 맺어야 한다&lt;/strong&gt;. TCP는 서버 컴퓨터에 대한 IP 주소와 그 서버에서 실행 중인 프로그램이 사용하는 포트번호가 필요하다.&lt;/p&gt;

&lt;p&gt;웹브라우저가 HTTP를 이용해서 멀리 떨어진 서버의 HTML 리소스를 사용자에게 보여주는 순서는 아래와 같다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;웹브라우저는 서버의 URL에서 호스트 명을 추출한다.&lt;/li&gt;
  &lt;li&gt;웹브라우저는 서버의 호스트 명을 IP로 변환한다.&lt;/li&gt;
  &lt;li&gt;웹브라우저는 URL에서 포트번호(있다면)를 추출한다.&lt;/li&gt;
  &lt;li&gt;웹브라우저는 웹 서버와 TCP 커넥션을 맺는다.&lt;/li&gt;
  &lt;li&gt;웹브라우저는 서버의 HTTP 요청을 보낸다.&lt;/li&gt;
  &lt;li&gt;웹브라우저는 웹브라우저에 있는 HTTP 응답을 돌려준다.&lt;/li&gt;
  &lt;li&gt;커넥션이 닫히면, 웹브라우저는 문서를 보여준다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;프락시&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;프락시&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;프락시는 클라이언트와 서버 사이에 위치하여, 클라이언트의 모든 HTTP 요청을 받아 서버에 전달&lt;/strong&gt;한다. 프락시는 주로 보안을 위해 사용되는데, 모든 웹 트래픽 흐름 속에서 신뢰할 만한 중개자 역할을 한다. 또한 &lt;strong&gt;프락시는 요청과 응답을 필터링&lt;/strong&gt;한다. 예를 들면 회사에서 무엇인가를 다운 받을 때 애플리케이션 바이러스를 검출하거나, 학교에서 학생들이 성인 컨텐츠에 접근하는 것을 차단하는 것 등이 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;캐시&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;캐시&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;웹캐시와 캐시 프락시는 자신을 거쳐 가는 문서들 중 자주 찾는 것의 사본을 저장해두는 특별한 종류의 HTTP 프락시 서버다&lt;/strong&gt;. 다음번에 클라이언트가 같은 문서를 요청하면 캐시가 갖고 있는 사본을 받을 수 있다. 클라이언트는 멀리 떨어진 웹 서버보다 근처의 캐시에서 훨씬 더 빨리 문서를 다운 받을 수 있다.&lt;br /&gt;
HTTP는 캐시를 효율적으로 동작하게 하고 캐시된 컨텐츠를 최신 버전으로 유지하면서 동시에 프라이버시도 보호하기 위한 많은 기능을 정의한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;게이트웨이&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;게이트웨이&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;게이트웨이는 다른 서버들의 중개자로 동작하는 특별한 서버다&lt;/strong&gt;.&lt;br /&gt;
게이트웨이는 주로 HTTP 트래픽을 다른 프로토콜로 변환하기 위해 사용되는데, 게이트웨이는 언제나 스스로가 리소스를 갖고 잇는 진짜 서버인 것처럼 요청을 다룬다.&lt;/p&gt;

&lt;p&gt;예를 들면 HTTP/FTP 게이트웨이는&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;FTP URI에 대한 HTTP 요청을 받아들인 뒤, FTP 프로토콜을 이용해 문서를 가져온다.&lt;/li&gt;
  &lt;li&gt;받아온 문서는 HTTP 메시지에 담겨 클라이언트에게 보낸다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;터널&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;터널&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;터널은 두 커넥션 사이에서 날(raw) 데이터를 열어보지 않고 그대로 전달해주는 HTTP 애플리케이션이다&lt;/strong&gt;. HTTP 터널은 주로 비 HTTP 데이터를 하나 이상의 HTTP 연결을 통해 그대로 전송해주기 위해 사용된다.&lt;br /&gt;
HTTP 터널을 활용하는 대표적인 예로, 암호화된 SSL 트래픽을 HTTP 커넥션으로 전송함으로써 웹 트래픽만 허용하는 사내 방화벽을 통과시키는 것이 있다.&lt;/p&gt;

&lt;p&gt;HTTP/SSL 터널은&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;HTTP 요청을 받아들여 목적지의 주소와 포트번호로 커넥션을 맺는다.&lt;/li&gt;
  &lt;li&gt;암호화된 SSL 트래픽을 HTTP 채널을 통해 목적지 서버로 전송할 수 있게 된다.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;에이전트&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;에이전트&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;사용자 에이전트는 사용자를 위해 HTTP 요청을 만들어주는 클라이언트 프로그램이다&lt;/strong&gt;.&lt;br /&gt;
웹 요청을 만드는 애플리케이션은 모두 HTTP 에이전트다. 이러한 사용자 에이전트에는 여러 가지 종류가 있는데, 사람의 통제 없이 스스로 웹을 돌아다니며 HTTP 트랜잭션을 일으키고 컨텐츠를 받아오는 스파이더(웹 크롤러)도 사용자 에이전트에 속한다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
데이빗 고울리·브라이언 토티·마조리 세이어·세일루 레디·안슈 아가왈. (2014). HTTP 완벽 가이드. 프로그래밍인사이트&lt;/p&gt;
</description>
        <pubDate>Sun, 19 Sep 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/http/opening/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/http/opening/</guid>
        
        <category>2021년 09월</category>
        
        
        <category>HTTP</category>
        
      </item>
    
      <item>
        <title>상태 레지스터와 시프터</title>
        <description>&lt;h2 id=&quot;상태-레지스터&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;상태 레지스터&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;상태 레지스터는 &lt;strong&gt;ALU에서 산술연산을 수행한 후 연산 결과에 의해 상태 레지스터를 세트&lt;/strong&gt;한다. 
상태 레지스터들은 &lt;strong&gt;C(carry bit)&lt;/strong&gt;, &lt;strong&gt;S(sign bit)&lt;/strong&gt;, &lt;strong&gt;Z(zero bit)&lt;/strong&gt;, &lt;strong&gt;V(overflow bit)&lt;/strong&gt;로 구성되어 있으며, &lt;strong&gt;1개 상태가 1개 비트씩 기억될 수 있도록 비트 단위로 구성&lt;/strong&gt;되어 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;ALU에서 &lt;strong&gt;산술연산이 수행된 후 연산결과에 의해 나타나는 상태값을 저장&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;상태 레지스터는 C(carry bit), S(sign bit), Z(zero bit), V(overflow bit)로 구성
&lt;img src=&quot;/assets/images/computer-structure/flagRegister.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;캐리비트(carry bit)&lt;/span&gt;&lt;br /&gt;
캐리비트는 &lt;strong&gt;두 수를 가산하여 캐리가 발생하면 비트가 1로 세트되고, 아니면 0&lt;/strong&gt;이된다. 따라서 캐리비트는 산술연산장치의 최상위 비트의 전가산기 캐리 아웃(carry out) 신호를 받아서 세트된다. 또한 감산에서 자리내림(borrow)이 발생했을 때도 1로 세트된다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;부호비트(sign bit)&lt;/span&gt;&lt;br /&gt;
부호비트는 산술연산장치의 출력 최상위 비트와 연결되어 있으며, &lt;strong&gt;최상위 비트가 0이면 양수를 나타내고, 1이면 음수&lt;/strong&gt;를 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;제로비트(zero bit)&lt;/span&gt;&lt;br /&gt;
제로비트는 &lt;strong&gt;두 수를 연산한 후 결과값이 0이며 1로 세트&lt;/strong&gt;된다. 따라서 산술연산장치의 출력비트들을 논리게이트 NOR에 연결하여 모든 비트가 0이면 출력밧이 1이 되도록 구성한다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;오버플로 비트(overflow bit)&lt;/span&gt;&lt;br /&gt;
오버플로는 산술연산에서 &lt;strong&gt;두 수를 가산할 때 결과를 저장할 수 있는 레지스터의 자릿수가 모자라는 경우에 발생&lt;/strong&gt;하는 에러로서, 오버플로가 발생하면 오버플로 비트가 1로 세트된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;시프터shifter&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;시프터(shifter)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;ALU에는 데이터를 비트 단위로 이동시키는 시프트(shift) 기능이 없다. 따라서 &lt;strong&gt;ALU 출력 단에 시프터(shifter)를 연결하여 시프터 연산을 수행&lt;/strong&gt;한다. 시프트 연산은 입력 데이터의 모든 비트를 각각 서로 이웃한 비트로 자리를 옮기는 연산을 말하여, 왼쪽 시프트와 오른쪽 시프트가 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;입력 데이터의 모든 비트들을 각각 서로 이웃한 비트로 자리를 옮기는 시프트 연산을 수행
&lt;img src=&quot;/assets/images/computer-structure/shifter.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;시프터에 대한 연산표는 다음과 같다.
&lt;img src=&quot;/assets/images/computer-structure/shifter2.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
김형근·손진곤 (공저). (2021). 컴퓨터구조. 한국방송통신대학교출판문화원&lt;/p&gt;
</description>
        <pubDate>Sat, 18 Sep 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/computer-science/status-register/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/computer-science/status-register/</guid>
        
        <category>2021년 09월</category>
        
        
        <category>computer-science</category>
        
      </item>
    
      <item>
        <title>처리장치의 구성요소</title>
        <description>&lt;h2 id=&quot;처리장치의-구성요소&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;처리장치의 구성요소&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;처리장치는 여러 가지 마이크로연산을 수행할 수 있도록 레지스터와 ALU(산술/논리연산장치), 레지스터와 ALU는 연결선로인 버스(bus)로 연결된다.&lt;br /&gt;
따라서 &lt;strong&gt;처리장치는 여러 개의 레지스터, ALU, 내부버스로 구성&lt;/strong&gt;된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer-structure/InternalComposition.png&quot; alt=&quot;img.png&quot; /&gt;&lt;br /&gt;
위 그림은 처리장치의 내부 구성도로 &lt;strong&gt;레지스터와 ALU, 시프터(shifer), 디지털 논리회로로 구성&lt;/strong&gt;되어 있다.&lt;br /&gt;
&lt;strong&gt;처리장치의 동작원리는&lt;/strong&gt; 우선 하나의 마이크로연산이 실행되기 위해서 지정된 출발 레지스터의 내용이 ALU의 입력으로 전달되고, ALU에서 그 연산을 실행한 후 그 결과가 도착 레지스터에 전송된다. 처리장치에 있는 각 레지스터는 ALU와 연결된 버스를 통해 2개의 멀티플렉서와 연결된다. 각 멀티플렉서는 선택신호를 이용하여 특정 레지스터를 선택한다. 2개의 멀티플렉서에 의해 선택된 데이터는 ALU에 의해 산술 및 논리연산을 실행한다. 즉, ALU에 있는 선택신호에 의해 실행되어야 할 특정 마이크로연산이 선택되는 것이다. ALU에서 실행된 마이크로연산의 결과는 시프트 레지스터를 거치게 된다. 스프트 레지스터에서 선택신호는 특정 마이크로연산을 선택할 수 있게하고, 그 결과는 연결된 버스를 통해 레지스터들의 입력으로 전달된다. 여기서 디코더는 처리장치의 각 레지스터와 연결되어 있으며, 선택신호에 따라 도착 레지스터를 결정하게 된다. 따라서 결정된 도착 레지스터에는 지금까지 수행된 마이크로연산의 결과가 저장된다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;이 과정을 요약하면 다음과 같다.&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;지정된 &lt;strong&gt;출발 레지스터의 내용을 ALU의 입력으로 전달&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;ALU에서 그 &lt;strong&gt;연산을 실행&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;그 결과가 &lt;strong&gt;도착 레지스터에 전송&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;내부버스&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;내부버스&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;내부버스란 &lt;strong&gt;중앙처리장치 내부의 연산장치와 레지스터 사이의 정보 전송 경로&lt;/strong&gt;를 말하며, 외부버스는 &lt;strong&gt;중앙처리장치와 중앙처리장치 외부의 장치 사이에 정보를 전송하는 경로&lt;/strong&gt;를 말한다.&lt;br /&gt;
&lt;strong&gt;외부버스는 시스템버스로서, 컴퓨터 시스템의 각 구성요소 간의 통신이 가능하도록 하는 기능&lt;/strong&gt;을 하는데, 주기억장치와 중앙처리장치 사이의 주기억장치버스, 입출력장치와 중앙처리장치 사이의 입출력버스 등이 있다.&lt;br /&gt;
&lt;strong&gt;내부버스는 처리장치 내부에 있는 레지스터 간의 통신이 가능하도록 하는 기능&lt;/strong&gt;을 하는데, 처리장치 내부에 각 레지스터는 그 안에 저장된 정보를 입력버스를 통해 연산장치로 전송하고, 연산장치에서의 연산 결과는 출력버스를 통해 해당 목적지 레지스터로 전송된다. 이러한 내부버스는 멀티플렉서와 디코더를 이용하여 구성하는데, 멀티플렉서는 출발 레지스터를 선택하고, 디코더는 버스로부터 정보를 받아들이는 도착 레지스터를 선택한다.&lt;/p&gt;

&lt;p&gt;내부버스를 구성하는 방법은 멀티플렉서와 디코더를 이용한다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;멀티플렉서는 출발 레지스터&lt;/strong&gt; 선택&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;디코더는 도착 레지스터&lt;/strong&gt; 선택
&lt;img src=&quot;/assets/images/computer-structure/internalBus.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;내부버스의-구성-및-동작&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;내부버스의 구성 및 동작&lt;/span&gt;&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;마이크로 연산 : R1 &amp;lt;- R0(R0, R1이 4비트 레지스터인 경우)
    &lt;ul&gt;
      &lt;li&gt;내부버스 구성을 위해 : &lt;strong&gt;2x1 MUX 4개, 1x2 디코더 1개&lt;/strong&gt; 필요&lt;/li&gt;
      &lt;li&gt;마이크로 연산을 위해 : MUX의 선택신호 0(2진수), 디코더의 선택신호는 1(2진수) 부여
&lt;img src=&quot;/assets/images/computer-structure/internalBus2.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
김형근·손진곤 (공저). (2021). 컴퓨터구조. 한국방송통신대학교출판문화원&lt;/p&gt;
</description>
        <pubDate>Sat, 18 Sep 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/computer-science/components-processing/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/computer-science/components-processing/</guid>
        
        <category>2021년 09월</category>
        
        
        <category>computer-science</category>
        
      </item>
    
      <item>
        <title>산술/논리연산장치</title>
        <description>&lt;h2 id=&quot;산술논리연산장치&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;산술/논리연산장치&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;ALU는 &lt;strong&gt;기본적인 산술연산과 논리연산을 실행하는 조합논리회로&lt;/strong&gt;다. ALU에는 특정한 연산을 선택하기 위하여 몇 개의 선택입력선이 주어진다. 선택입력선은 ALU 내에서 디코드되는데, k개의 선택입력으로 최대 2^k에 해당하는 서로 다른 연산을 표시할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer-structure/ALU.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;또한, &lt;strong&gt;산술연산회로와 논리연산회로를 결합하여 하나의 ALU&lt;/strong&gt;를 만들어 낼 수 있다.
&lt;img src=&quot;/assets/images/computer-structure/ALU6.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;ALU에 대한 연산표는 다음과 같다.
&lt;img src=&quot;/assets/images/computer-structure/ALU7.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;산술연산회로&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;산술연산회로&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;산술연산회로의 가장 기본적인 구성요소는 &lt;strong&gt;병렬가산기이며, 여러개의 전가산기 회로를 연속적으로 연결&lt;/strong&gt;시켜 만든다. 병렬가산기로 들어가는 제어입력값을 선액하면 여러 가지 형태의 산술연산을 실행할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;여러 개의 전가산기(FA)를 연속적으로 연결한 병렬가산기로 구성&lt;/li&gt;
  &lt;li&gt;병렬가산기로 들어가는 제어입력 값을 선택하여 여러 가지 형태의 산술연산을 실행&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer-structure/ALU2.png&quot; alt=&quot;img.png&quot; /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;산술연산회로에 대한 연산표는 다음과 같다.
&lt;img src=&quot;/assets/images/computer-structure/ALU3.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;논리연산회로&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;논리연산회로&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;논리연산은 &lt;strong&gt;레지스터에 있는 각 비트를 독립된 2진 변수로 간주하여 비트별 연산을 실행&lt;/strong&gt;한다. 논리연산에는 &lt;strong&gt;AND&lt;/strong&gt;, &lt;strong&gt;OR&lt;/strong&gt;, &lt;strong&gt;XOR&lt;/strong&gt;, &lt;strong&gt;NOT&lt;/strong&gt; 등이 있고 이를 이용하여 복잡한 연산을 유도할 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;레지스터에 있는 각 비트를 독립된 2진 변수로 간주하여 비트별 연산 실행&lt;/li&gt;
  &lt;li&gt;AND, OR, XOR, NOT 연산 등이 있으며, 이를 이용하여 복잡한 연산을 유도&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/computer-structure/ALU4.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;논리연산회로에 대한 연산표는 다음과 같다.
&lt;img src=&quot;/assets/images/computer-structure/ALU5.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
김형근·손진곤 (공저). (2021). 컴퓨터구조. 한국방송통신대학교출판문화원&lt;/p&gt;
</description>
        <pubDate>Sat, 18 Sep 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/computer-science/alu/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/computer-science/alu/</guid>
        
        <category>2021년 09월</category>
        
        
        <category>computer-science</category>
        
      </item>
    
  </channel>
</rss>