<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  
  <channel>
    <title> Hyuuny`s Blog  </title>
    <description>객체지향과 DDD에 관심이 많은 백엔드개발자로서, 최근에는 리눅스와 도커에 관심이 생겨 함께 공부하고 있습니다.</description>
    <link>https://hyuuny.github.io/</link>
    <atom:link href="https://hyuuny.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sat, 06 Nov 2021 21:14:05 +0900</pubDate>
    <lastBuildDate>Sat, 06 Nov 2021 21:14:05 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>의존성 주입(Dependency Injection)</title>
        <description>&lt;p&gt;DI는 디자인 패턴으로 크게 다음과 같이 4가지 방법이 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;생성자 주입&lt;/li&gt;
  &lt;li&gt;setter 주입&lt;/li&gt;
  &lt;li&gt;필드 주입(@Autowired)&lt;/li&gt;
  &lt;li&gt;일반 메서드 주입&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;생성자-주입&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;생성자 주입&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;이름 그대로 생성자를 통해서 의존 관계를 주입 받는 방법&lt;/li&gt;
  &lt;li&gt;생성자 호출 시점에 &lt;strong&gt;단 1번만 호출&lt;/strong&gt;되는 것이 보장된다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;불변, 필수&lt;/strong&gt; 의존 관계에 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OrderServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;memberRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;strong&gt;생성자가 1개만 있으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;를 생략해도 자동 주입 된다.&lt;/strong&gt; (스프링 빈에만 해당)&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;// 생성자가 1개일 경우, @Autowired 생략 가능&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OrderServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;memberRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;setter-주입&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;setter 주입&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;필드의 값을 변경하는 수정자 메서드(setter)를 통해서 의존관계를 주입하는 방법&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;선택, 변경&lt;/strong&gt; 가능성이 있는 의존 관계에 사용&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setMemberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;memberRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;setDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;의 기본 동작은 주입할 대상이 없으면 오류가 발생&lt;/strong&gt;하므로, 주입할 대상이 없어도 동작하게 하려면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired(required = false)&lt;/code&gt;로 지정해야 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;필드-주입autowired&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;필드 주입(@Autowired)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;이름 그대로 필드에 바로 주입하는 방법&lt;/li&gt;
  &lt;li&gt;코드가 간결해서 많은 개발자들을 유혹하지만, 외부에서 변경이 불가능해서 테스트 하기 힘들다.&lt;/li&gt;
  &lt;li&gt;DI 프레임워크가 없으면 아무것도 할 수 없다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;아래 두 경우를 제외하곤, 사용하지 말자!&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;애플리케이션의 실제 코드와 관계 없는 &lt;strong&gt;테스트 코드&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;스프링 설정을 목적으로 하는 @Configuration 같은 곳에서만 특별한 용도로 사용&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;순수한 자바 테스트 코드에는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;가 동작하지 않는다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@SpringBootTest&lt;/code&gt;처럼 스프링 컨테이너를 테스트에 통합한 경우에만 가능&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;일반-메서드-주입&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;일반 메서드 주입&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;일반 메서드를 통해서 주입 받는 방법&lt;/li&gt;
  &lt;li&gt;한번에 &lt;strong&gt;여러 필드&lt;/strong&gt;를 주입 받을 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;일반적으로 잘 사용하지 않는다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;init&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;memberRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Sat, 06 Nov 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/dependency-injection/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/dependency-injection/</guid>
        
        <category>2021년 11월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>컴포넌트 스캔(@ComponentScan)</title>
        <description>&lt;p&gt;스프링은 설정 정보가 없어도 없어도 자동으로 스프링 빈을 등록하는 컴포넌트 스캔이라는 기능을 제공한다. 또 의존 관계도 자동으로 주입하는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;도 제공한다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AutoAppConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;컴포넌트 스캔을 사용하려면 먼저 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ComponentScan&lt;/code&gt;을 설정 정보에 붙여주면 된다.&lt;/li&gt;
  &lt;li&gt;기존의 AppConfig와는 다르게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;으로 등록한 클래스가 하나도 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Configuration&lt;/code&gt;이 컴포넌트 스캔의 대상이 된 이유도 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Configuration&lt;/code&gt; 소스코드를 열어보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt; 애노테이션이 붙어있기 때문이다.
&lt;img src=&quot;/assets/images/spring/configuration1.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;strong&gt;컴포넌트 스캔의 대상이 될 클래스에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt; 애노테이션을 붙여주자.&lt;/strong&gt;&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemoryMemberRepository&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;RateDiscountPolicy&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MemberServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;memberRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Component&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;nd&quot;&gt;@Autowired&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OrderServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; 
                            &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;memberRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;discountPolicy&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;이전에 AppConfig에서는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;으로 직접 설정 정보를 작성했고, 의존관계도 직접 명시했다. &lt;strong&gt;이제는 이런 설정 정보 자체가 없기 때문에, 의존관계 주입도 이 클래스 안에서 해결해야 한다&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;는 의존관계를 자동으로 주입해준다&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;위 설정 정보로 테스트 해본 결과는 아래와 같다.&lt;/p&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AutoConfigTest&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
  &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;basicScan&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ac&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnnotationConfigApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AutoAppConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;Assertions&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;assertThat&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memberService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;).&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;isInstanceOf&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/component-scan-test.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;로그의 3~6 번째 줄을 잘 보면 컴포넌트 스캔이 잘 동작하는 것을 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ClassPathBeanDefinitionScanner - Identified candidate component class:
.. RateDiscountPolicy.class
.. MemberServiceImpl.class
.. MemoryMemberRepository.class
.. OrderServiceImpl.class
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;컴포넌트-스캔과-자동-의존관계-주입-동작-방식&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;컴포넌트 스캔과 자동 의존관계 주입 동작 방식&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;1. @ComponenetScan&lt;/strong&gt;
&lt;img src=&quot;/assets/images/spring/component-scan1-1.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@ComponentScan&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component&lt;/code&gt;가 붙은 모든 클래스를 스프링 빈으로 등록한다.&lt;/li&gt;
  &lt;li&gt;이때 스프링 빈의 기본 이름은 클래스명을 사용하되, 맨 앞글자만 소문자를 사용한다.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;빈 이름 기본 전략&lt;/strong&gt; : MemberServiceImpl 클래스 memberServiceImpl&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;빈 이름 직접 지정&lt;/strong&gt; : 만약 스프링 빈의 이름을 직접 지정하고 싶으면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Component(&quot;memberService2&quot;)&lt;/code&gt; 이런식으로 이름을 부여하면 된다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;2. @Autowired 의존관계 자동 주입&lt;/strong&gt;
&lt;img src=&quot;/assets/images/spring/component-scan1-2.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;생성자에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Autowired&lt;/code&gt;를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.&lt;/li&gt;
  &lt;li&gt;이때 기본 조회 전략은 &lt;strong&gt;타입이 같은&lt;/strong&gt; 빈을 찾아서 주입한다.
    &lt;ul&gt;
      &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;getBean(MemberRepository.class)&lt;/code&gt;와 동일하다고 이해하면 된다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/component-scan1-3.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;생성자에 파라미터가 많아도 다 찾아서 자동으로 주입한다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 01 Nov 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/component-scan/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/component-scan/</guid>
        
        <category>2021년 11월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>Configuration과 Singleton</title>
        <description>&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; &lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

      &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;memberService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MemberServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;orderService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OrderServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

      &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
      &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
          &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MemoryMemberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
      &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;...&lt;/span&gt; 

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;memberService 빈을 만드는 코드를 보면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memberRepository()&lt;/code&gt;를 호출한다.&lt;/li&gt;
  &lt;li&gt;orderService 빈을 만드는 코드도 동일하게 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;memberRepository()&lt;/code&gt;를 호출한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;new연산자&lt;/code&gt;를 통해 각각 다른 2개의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MemoryMemberRepository&lt;/code&gt;가 생성되면서 싱글톤이 깨지는 것 처럼 보이는데, 스프링 컨테이너는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;이 붙은 메서드를 한 번만 호출해서 등록하고 이를 재사용한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;configuration과-바이트코드-조작&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;@Configuration과 바이트코드 조작&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;스프링 컨테이너는 싱글톤 레지스트리다. 따라서 스프링 빈이 싱글톤이 되도록 보장해주어야 한다. 그런데 스프링이 자바 코드까지 어떻게 하기는 어렵다. 위 코드를 보면 분명 3번 호출되어야 하는 것이 맞다. 그래서 스프링은 클래스의 바이트코드를 조작하는 라이브러리를 사용한다.&lt;br /&gt;
모든 비밀은 &lt;strong&gt;@Configuration 을 적용한 AppConfig&lt;/strong&gt;에 있다.&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Test&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;configurationDeep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ac&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;AnnotationConfigApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;

    &lt;span class=&quot;c1&quot;&gt;//AppConfig도 스프링 빈으로 등록된다.&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bean&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ac&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;nc&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;bean = &quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;bean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getClass&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//출력: bean = class hello.core.AppConfig$$EnhancerBySpringCGLIB$$bd479d70&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;AnnotationConfigApplicationContext&lt;/code&gt;에 파라미터로 넘긴 값은 스프링 빈으로 등록된다. 그래서 AppConfig도 스프링 빈이 된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;순수한 클래스라면 &lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class hello.core.AppConfig&lt;/code&gt;&lt;/strong&gt;와 같이 출력되어야 하지만,&lt;/p&gt;

&lt;p&gt;AppConfig 스프링 빈을 조회해서 클래스 정보를 출력해보면&lt;br /&gt;
&lt;strong&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;class hello.core.AppConfig$$EnhancerBySpringCGLIB$$bd479d70&lt;/code&gt;&lt;/strong&gt;와 같이 출력된다.&lt;/p&gt;

&lt;p&gt;스프링 빈을 조회해서 출력한 클래스 명에 xxxCGLIB가 붙은 것을 확인 할 수 있는데, 이것은 내가 만든 클래스가 아니라 &lt;strong&gt;스프링이 CGLIB라는 바이트코드 조작 라이브러리를 사용해서 AppConfig 클래스를 상속받은 임의의 다른 클래스를 만들고, 이를 스프링 빈으로 등록했기 때문이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/configuration.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;AppConfig를 상속받은 임의의 클래스가 싱글톤이 보장되도록 해준다.&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;AppConfig@CGLIB 예상 코드&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memoryMemberRepository가&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;이미&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;스프링&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;컨테이너에&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;등록되어&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;있으면&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;?)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; 
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;스프링&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;컨테이너에서&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;찾아서&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;else&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;//스프링 컨테이너에 없으면&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;기존&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;로직을&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;호출해서&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemoryMemberRepository를&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;생성하고&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;스프링&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;컨테이너에&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;등록&lt;/span&gt;
            &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;반환&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; 

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;@Bean이 붙은 메서드마다 이미 스프링 빈이 존재하면 존재하는 빈을 반환하고, 스프링 빈이 없으면 생성해서 스프링 빈으로 등록하고 반환하는 코드가 동적으로 만들어진다.
    &lt;ul&gt;
      &lt;li&gt;그로 인해 싱글톤이 보장 됨&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;AppConfig@CGLIB는 AppConfig의 자식 타입이므로, AppConfig 타입으로 조회 할 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;@Configuration을 적용하지 않고, @Bean만 적용한 경우&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 빈으로 등록되지만, 매번 객체를 생성한다.(싱글톤을 보장하지 않음)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 31 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/configuration/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/configuration/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>Singleton, SingletonContainer</title>
        <description>&lt;h2 id=&quot;싱글톤sigleton&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;싱글톤(Sigleton)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;클래스의 인스턴스가 딱 1개만 생성되는 것을 보장하는 디자인 패턴이다.&lt;/li&gt;
  &lt;li&gt;객체 인스턴스를 2개 이상 생성하지 못하도록 막아야 한다.
    &lt;ul&gt;
      &lt;li&gt;private 생성자를 사용해서 외부에서 임의로 new 키워드를 사용하지 못하도록 막아야 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;싱글톤 패턴의 문제점&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.&lt;/li&gt;
  &lt;li&gt;의존관계상 클라이언트가 구체 클래스에 의존한다. DIP를 위반한다.&lt;/li&gt;
  &lt;li&gt;클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.&lt;/li&gt;
  &lt;li&gt;테스트하기 어렵다.&lt;/li&gt;
  &lt;li&gt;내부 속성을 변경하거나 초기화 하기 어렵다.&lt;/li&gt;
  &lt;li&gt;private 생성자로 자식 클래스를 만들기 어렵다.&lt;/li&gt;
  &lt;li&gt;결론적으로 유연성이 떨어진다.&lt;/li&gt;
  &lt;li&gt;안티패턴으로 불리기도 한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;싱글톤-컨테이너sigleton-container&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;싱글톤 컨테이너(Sigleton Container)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;스프링 컨테이너는 싱글톤 패턴의 문제점을 해결하면서, 객체 인스턴스를 싱글톤(1개만 생성)으로 관리한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리한다.&lt;/li&gt;
  &lt;li&gt;스프링 컨테이너는 싱글톤 컨테이너 역할을 한다. 이렇게 싱글톤 객체를 생성하고 관리하는 기능을 싱글톤 레지스트리라 한다.&lt;/li&gt;
  &lt;li&gt;스프링 컨테이너의 이런 기능 덕분에 싱글턴 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.&lt;/li&gt;
  &lt;li&gt;싱글톤 패턴을 위한 지저분한 코드가 들어가지 않아도 된다.&lt;/li&gt;
  &lt;li&gt;DIP, OCP, 테스트, private 생성자로 부터 자유롭게 싱글톤을 사용할 수 있다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;싱글톤 컨테이너 테스트&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/singleton-test1-1.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;AppConif 설정 클래스에서 각각(memberService1, memberService2) 가져온다.&lt;/li&gt;
  &lt;li&gt;memberService1과 memberService2가 &lt;strong&gt;같은 객체인지&lt;/strong&gt; 확인한다.
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/singleton-test1-2.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;스프링 컨테이너 덕분에 고객의 요청이 올 때 마다 &lt;strong&gt;객체를 생성하는 것이 아니라, 이미 만들어진 객체를 공유&lt;/strong&gt;해서 효율적으로 재사용할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;이를 그림으로 표현하면 아래와 같다.
&lt;img src=&quot;/assets/images/spring/singleton-test1-3.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;blockquote&gt;
    &lt;p&gt;스프링의 기본 빈 등록 방식은 싱글톤이지만, 싱글톤 방식만 지원하는 것은 아니다. 요청할 때 마다 새로운 객체를 생성해서 반환하는 기능도 제공한다.&lt;/p&gt;
  &lt;/blockquote&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;싱글톤-방식의-주의점&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;싱글톤 방식의 주의점&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;싱글톤 패턴이든, 스프링 같은 싱글톤 컨테이너를 사용하든, 객체 인스턴스를 하나만 생성해서 공유하는 싱글톤 방식은 여러 클라이언트가 하나의 같은 객체 인스턴스를 공유하기 때문에 &lt;strong&gt;싱글톤 객체는 상태를 유지(stateful)하게 설계하면 안된다&lt;/strong&gt;.&lt;/li&gt;
  &lt;li&gt;즉, 무상태(stateless)로 설계해야 한다.
    &lt;ul&gt;
      &lt;li&gt;특정 클라이언트에 의존적인 필드가 있으면 안된다.&lt;/li&gt;
      &lt;li&gt;특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;가급적 읽기만&lt;/strong&gt; 가능해야 한다.&lt;/li&gt;
      &lt;li&gt;필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;스프링 빈의 필드에 공유 값을 설정하면 정말 큰 장애가 발생할 수 있다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 27 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/sington/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/sington/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>IoC, DI, Container</title>
        <description>&lt;h2 id=&quot;제어의-역전inversion-of-control&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;제어의 역전(Inversion of Control)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행했다. 한마디로 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다.&lt;/li&gt;
  &lt;li&gt;AppConfig가 등장한 이후에 구현 객체는 자신의 로직을 실행하는 역할만 담당한다. 프로그램의 제어 흐름은 이제 AppConfig가 가져간다.
    &lt;ul&gt;
      &lt;li&gt;예를 들어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt; 은 필요한 인터페이스들(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repository&lt;/code&gt;와 같은)을 호출하지만 어떤 구현 객체들이 실행될지 모른다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그램에 대한 제어 흐름에 대한 권한은 모두 AppConfig가 가지고 있다. 심지어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt;도 AppConfig가 생성한다.
    &lt;ul&gt;
      &lt;li&gt;AppConfig는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt; 이 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderService&lt;/code&gt; 인터페이스의 다른 구현 객체를 생성하고 실행할 수 도 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이렇듯 프로그램의 &lt;strong&gt;제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)&lt;/strong&gt;이라 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;프레임워크와 라이브러리&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 프레임워크이다.&lt;/li&gt;
  &lt;li&gt;내가 작성한 코드가 직접 제어의 흐름을 담당한다면 프레임워크가 아니라 라이브러리다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;의존관계-주입-didependency-injection&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;의존관계 주입 DI(Dependency Injection)&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DiscountPolicy&lt;/code&gt; 인터페이스에 의존한다. 실제 어떤 구현 객체가 사용될지는
모른다.&lt;/li&gt;
  &lt;li&gt;의존관계는 &lt;strong&gt;정적인 클래스 의존 관계&lt;/strong&gt;와, &lt;strong&gt;실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계&lt;/strong&gt; 둘을 분리해서 생각해야 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;정적인 클래스 의존관계&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다. 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MemberRepository&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DiscountPolicy&lt;/code&gt;에 의존한다는 것을 알 수 있다.
그런데 이러한 클래스 의존관계 만으로는 실제 어떤 객체가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt;에 주입 될지 알 수 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/di1.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;동적인 객체 인스턴스 의존 관계&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;애플리케이션 실행 시점에&lt;/strong&gt; 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/di2.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;애플리케이션 &lt;strong&gt;실행 시점(런타임)&lt;/strong&gt;에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 &lt;strong&gt;의존관계 주입&lt;/strong&gt;이라 한다.&lt;/li&gt;
  &lt;li&gt;객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다.&lt;/li&gt;
  &lt;li&gt;의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.&lt;/li&gt;
  &lt;li&gt;의존관계 주입을 사용하면 &lt;strong&gt;정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경&lt;/strong&gt;할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ioc-컨테이너-di-컨테이너&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;IoC 컨테이너, DI 컨테이너&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;AppConfig 처럼 &lt;strong&gt;객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 DI 컨테이너&lt;/strong&gt;라 한다.&lt;/li&gt;
  &lt;li&gt;의존관계 주입에 초점을 맞추어 &lt;strong&gt;최근에는 주로 DI 컨테이너&lt;/strong&gt;라 한다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/IoC-DI-Container/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/IoC-DI-Container/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>ApplicationContext</title>
        <description>&lt;h2 id=&quot;config-기반-bean-설정&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;Config 기반 Bean 설정&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;memberService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MemberServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MemoryMemberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;orderService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OrderServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountpolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;discountpolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RateDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;AppConfig에 설정을 구성한다는 뜻의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Configuration&lt;/code&gt;을 붙여준다.&lt;/li&gt;
  &lt;li&gt;각 메서드에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;을 붙여준다. 이렇게 하면 &lt;strong&gt;메서드에서 반환하는 객체를 스프링 컨테이너에 스프링 빈으로 등록&lt;/strong&gt;한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;스프링-컨테이너에-등록한-bean-꺼내서-사용하기&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;스프링 컨테이너에 등록한 Bean 꺼내서 사용하기&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// parameter : @Coufiguration이 붙은 구성 클래스&lt;/span&gt;
 &lt;span class=&quot;nc&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;applicationContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnnotationConfigApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;// parameter : 빈이름, 반환타입&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;applicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;memberService&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);/&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;memberA&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Grade&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;VIP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;memberService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ApplicationContext를 스프링 컨테이너&lt;/strong&gt;라 한다.&lt;/li&gt;
  &lt;li&gt;기존에는 개발자가 AppConfig 를 사용해서 직접 객체를 생성하고 DI를 했지만, 이제부터는 스프링 컨테이너를 통해서 사용한다.&lt;/li&gt;
  &lt;li&gt;스프링 컨테이너는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Configuration&lt;/code&gt;이 붙은 AppConfig 를 설정(구성) 정보로 사용한다. 여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 이렇게 &lt;strong&gt;스프링 컨테이너에 등록된 객체를 스프링 빈&lt;/strong&gt;이라 한다.&lt;/li&gt;
  &lt;li&gt;스프링 빈은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;이 붙은 &lt;strong&gt;메서드의 명을 스프링 빈의 이름으로 사용&lt;/strong&gt;한다.&lt;/li&gt;
  &lt;li&gt;이전에는 개발자가 필요한 객체를 AppConfig 를 사용해서 직접 조회했지만, 이제부터는 스프링 컨테이너를 통해서 필요한 스프링 빈(객체)를 찾아야 한다. 스프링 빈은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applicationContext.getBean()&lt;/code&gt; 메서드를 사용해서 찾을 수 있다.&lt;/li&gt;
  &lt;li&gt;기존에는 개발자가 직접 자바코드로 모든 것을 했다면 이제부터는 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/spring-context.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 부트 실행 시, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;이 만들어지는 모습&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;스프링-컨테이너-생성-과정&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;스프링 컨테이너 생성 과정&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너는 XML(거의 사용 안 함)을 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스로 만들 수 있다.&lt;/li&gt;
  &lt;li&gt;더 정확하게는 스프링 컨테이너를 부를 때 BeanFactory , ApplicationContext 로 구분하지만,  BeanFactory 를 직접 사용하는 경우는 거의 없으므로 일반적으로 ApplicationContext 를 스프링 컨테이너라 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;1. 스프링 컨테이너 생성&lt;/strong&gt;
&lt;img src=&quot;/assets/images/spring/application-context1.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너를 생성할 때는 구성 정보(여기서는 AppConfig.class)를 지정해줘야 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. 스프링 빈 등록&lt;/strong&gt;
&lt;img src=&quot;/assets/images/spring/application-context2.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너는 파라미터 넘어온 설정 클래스 정보를 읽어, @Bean 으로 등록된 메서드의 반환 타입을 스프링의 빈으로 등록한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3. 스프링 빈 의존관계 설정 - 준비&lt;/strong&gt;
&lt;img src=&quot;/assets/images/spring/application-context3.png&quot; alt=&quot;img.png&quot; /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 스프링 빈 의존관계 설정 - 완료&lt;/strong&gt;
&lt;img src=&quot;/assets/images/spring/application-context4.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너는 설정 정보를 참고하여 의존관계를 주입(DI)한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;beanfactory와-applicationcontext&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;BeanFactory와 ApplicationContext&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/spring/application-context5.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;beanfactory&quot;&gt;&lt;strong&gt;BeanFactory&lt;/strong&gt;&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너의 최상위 인터페이스다.&lt;/li&gt;
  &lt;li&gt;스프링 빈을 관리하고 조회하는 역할을 담당한다.&lt;/li&gt;
  &lt;li&gt;getBean() 을 제공한다.&lt;/li&gt;
  &lt;li&gt;지금까지 우리가 사용했던 대부분의 기능은 BeanFactory가 제공하는 기능이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/application-context6.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;applicationcontext&quot;&gt;&lt;strong&gt;ApplicationContext&lt;/strong&gt;&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;BeanFactory 기능을 모두 상속받아서 제공한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메시지소스를 활용한 국제화 기능(MessageSource)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;환경변수(EnvironmentCapable)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;로컬, 개발, 운영등을 구분해서 처리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;애플리케이션 이벤트(ApplicationEventPublisher)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;이벤트를 발행하고 구독하는 모델을 편리하게 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;편리한 리소스 조회(ResourceLoader)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/ApplicationContext/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/ApplicationContext/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>SOLID 원칙</title>
        <description>&lt;p&gt;클린코드로 유명한 로버트 마틴이 &lt;strong&gt;좋은 객체 지향 설계의 5가지 원칙&lt;/strong&gt;을 정리하였다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SRP: 단일 책임 원칙(Single Responsibility Principle)&lt;/li&gt;
  &lt;li&gt;OCP: 개방-폐쇄 원칙(Opne Closed Principle)&lt;/li&gt;
  &lt;li&gt;LSP: 리스코프 치환 원칙(Liskov Substitution Principle)&lt;/li&gt;
  &lt;li&gt;ISP: 인터페이스 분리 원칙(Interface Segregation Principle)&lt;/li&gt;
  &lt;li&gt;DIP: 의존관계 역전 원칙(Dependency Inversion Principle)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;srp-단일-책임-원칙single-responsibility-principle&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;SRP 단일 책임 원칙(Single Responsibility Principle)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;한 클래스는 하나의 책임&lt;/strong&gt;을 가져야 한다.&lt;/li&gt;
  &lt;li&gt;하나의 책임이라는 기준은 모호하다.
    &lt;ul&gt;
      &lt;li&gt;클 수도 있고, 작을 수도 있다.&lt;/li&gt;
      &lt;li&gt;문맥과 상황에 따라 다르다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;중요한 기준은 변경&lt;/strong&gt;이다. 변경이 있을 때, 파급효과가 적으면 단일 책임원칙을 잘 따른 것
    &lt;ul&gt;
      &lt;li&gt;예) UI 변경, 객체의 생성과 사용을 분리&lt;/li&gt;
    &lt;/ul&gt;

    &lt;hr /&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ocp-개방-폐쇄-원칙opne-closed-principle&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;OCP 개방-폐쇄 원칙(Opne Closed Principle)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;소프트웨어 요소는 &lt;strong&gt;확장에는 열려&lt;/strong&gt;있으나, &lt;strong&gt;변경에는 닫혀&lt;/strong&gt;있어야 한다.&lt;/li&gt;
  &lt;li&gt;다형성을 활용하자.(역할과 구현을 분리)&lt;/li&gt;
  &lt;li&gt;인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현하자.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;예시&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Service 의존하고 있는 MemberReposiroty를 JdbcMEmberReposiroty로 변경해야 하는 상황.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//private MemberRepository memberRepository = new MemberRepository(); // 기존코드&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JdbcMemberReposiroty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 변경 코드&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;구현 객체를 변경하면 클라이언트 코드를 변경해야한다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;분명 다형성을 사용했지만, OCP 원칙을 지킬 수 없다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
    &lt;ul&gt;
      &lt;li&gt;여기서는 &lt;strong&gt;MemberReposiroty를 인터페이스로 두고, 이를 구현&lt;/strong&gt;하도록 하자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Service는 Repository 인터페이스만 바라봄으로써, Repository의 &lt;strong&gt;구현체가 무엇이든 상관 없다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;lsp-리스코프-치환-원칙liskov-substitution-principle&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;LSP 리스코프 치환 원칙(Liskov Substitution Principle)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램의 객체는 &lt;strong&gt;프로그램의 정확성을 깨드리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야&lt;/strong&gt; 한다.&lt;/li&gt;
  &lt;li&gt;다형성에서
    &lt;ul&gt;
      &lt;li&gt;하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것,&lt;/li&gt;
      &lt;li&gt;다형성을 지원하기 위한 원칙,&lt;/li&gt;
      &lt;li&gt;인터페이스를 구현한 구현체는 믿고 사용하려면 이 원칙이 필요하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단순히 컴파일에 성공한다고 다가 아니다.
    &lt;ul&gt;
      &lt;li&gt;예) 자동차 인터페이스의 엑셀은 앞으로 가는 기능
        &lt;ul&gt;
          &lt;li&gt;뒤로 가도록 구현하면 LSP 위반&lt;/li&gt;
          &lt;li&gt;느리더라도 앞으로 가야 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;isp-인터페이스-분리-원칙interface-segregation-principle&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;ISP 인터페이스 분리 원칙(Interface Segregation Principle)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;특정 클라이언트를 위한 인터페이스 &lt;strong&gt;여러 개가 범용 인터페이스 하나보다 낫다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;예) 자동차 인터페이스 -&amp;gt; 운전 인터페이스, 정비 인터페이스로 분리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인터페이스가 명확해지고, 대체 가능성이 높아&lt;/strong&gt;진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;dip-의존관계-역전-원칙dependency-inversion-principle&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;DIP 의존관계 역전 원칙(Dependency Inversion Principle)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로그래머는 &lt;strong&gt;“추상화에 의존해야지, 구체화에 의존하면 안된다.” 의존성 주입은 이 원칙을 따르는 방법 중 하나&lt;/strong&gt;다.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻&lt;/strong&gt;
&lt;strong&gt;역할(Role)에 의존하게 해야 한다는 것과 같다.&lt;/strong&gt; (구현에 의존하지 말자!)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클라이언트가 &lt;strong&gt;인터페이스에 의존하야 유연하게 구현체를 변경할 수 있다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;구현체에 의존하게 되면 변경이 아주 어려워진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 24 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/SOLID/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/SOLID/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>REST API란</title>
        <description>&lt;p&gt;REST는 Representational State Transfer의 약자로 아키텍처 스타일이다. 아키텍처 스타일은 아키텍처 패턴과는 조금 다른데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;아키텍처 패턴은 어떤 반복되는 문제 상황을 해결하는 도구&lt;/code&gt;이고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;아키텍처 스타일은 반복되는 아키텍처 디자인을 의미&lt;/code&gt;한다.&lt;br /&gt;
&lt;strong&gt;REST 아키텍처 스타일은 6가지 제약조건으로 구성되며, 이 가이드 라인을 따르는 API를 RESTfull API&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;REST 제약 조건&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;클라이언트-서버(Client-Server)&lt;/li&gt;
  &lt;li&gt;상태가 없는(stateless)&lt;/li&gt;
  &lt;li&gt;캐시되는 데이터(Cacheable)&lt;/li&gt;
  &lt;li&gt;일관적인 인터페이스(Uniform Interface)&lt;/li&gt;
  &lt;li&gt;레이어 시스템(Layered System)&lt;/li&gt;
  &lt;li&gt;코드-온-디맨트(Code-On-Demand)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;클라이언트-서버client-server&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;클라이언트-서버(Client-Server)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;클라이언트-서버는 리소스를 관리하는 서버가 존재하고, 다수의 클라이언트가 리소스를 소비하려고 네트워크를 통해 서버에 접근하는 구조를 말한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이런 구조 중 우리에게 가장 친숙한 것이 바로 웹 애플리케이션이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;리소스란 REST API가 리턴할 수 있는 모든 것(HTML, JSON, 이미지 등)을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;상태가-없는stateless&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;상태가 없는(stateless)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;상태가 없다는 것은 클라이언트가 서버에 요청을 보낼 때, 이전 요청의 영향을 받지 않음을 의미한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 로그인의 경우 서버는 로그인 상태를 유지하지 못하므로, 요청을 보낼 때마다 로그인 정보를 항상 함께 보내야 한다. 리소스를 수정한 후 수정한 상태를 유지해야 하는 경우에는 서버가 아닌 DB와 같은 곳에 상태를 저장해야한다.&lt;/p&gt;

&lt;p&gt;HTTP는 기본적으로 상테가 없는 프로토콜이다. 따라서 HTTP를 사용하는 웹 애플리케이션은 기본적으로 상태가 없는 구조를 따른다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;캐시되는-데이터cacheable&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;캐시되는 데이터(Cacheable)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;서버에서 리소스를 리턴할 때 캐시가 가능한지 아닌지 명시할 수 있어야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTTP에서는 cache-control이라는 헤더에 리소스의 캐시 여부를 명시할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;일관적인-인터페이스uniform-interface&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;일관적인 인터페이스(Uniform Interface)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;일관적인 인터페이스란, 시스템 또는 애플리케이션의 리소스에 접근할 때 인터페이스가 일관적이어야 한다는 뜻이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 어떤 정보를 가져오기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://example.com/water&lt;/code&gt;를 사용했다고 하자. 이때 정보를 업데이트 하는 데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://example2.com/water&lt;/code&gt;를 사용한다면 이것은 URI의 일관성이 있다고 볼 수 없다.&lt;/p&gt;

&lt;p&gt;또 다른 예로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://example.com/water&lt;/code&gt;는 JSON 형식의 리소스를 리턴했다. 그런데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://example.com/book&lt;/code&gt;은 HTML을 리턴했다. 이런 인터페이스는 타입에 일관성이 있다고 볼 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;요청의 형태와 응답의 형태가 애플리케이션 전반에 걸쳐 일관적이어야 한다는 것이 일관적인 인터페이스 방침이다&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;레이어-시스템layered-system&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;레이어 시스템(Layered System)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;클라이언트가 서버에 요청을 할 때, 여러 개의 레이어로 된 서버를 거칠 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 서버가 인증 서버, 캐싱 서커, 로드 밸런서를 거쳐서 최종적으로 애플리케이션에 도착한다고 가정하자. &lt;strong&gt;이 사이의 레이어들은 요청과 응답에 어떤 영향을 미치지 않으며, 클라이언트는 레이어 존재 유무를 알지 못한다&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;코드-온-디맨트code-on-demand&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;코드-온-디맨트(Code-On-Demand)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;클라이언트는 서버에 코드를 요청할 수 있고, 서버가 리턴한 코드를 실행할 수 있다.(선택 사항)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;REST는 HTTP와 다르다. REST는 HTTP를 이용해 구현하기 쉽고 대부분 그렇게 구현하지만, &lt;strong&gt;REST는 아키텍처&lt;/strong&gt;이고, &lt;strong&gt;HTTP는 REST 아키텍처를 구현할 때 사용하면 쉬운 프로토콜&lt;/strong&gt;이다.&lt;/p&gt;

</description>
        <pubDate>Fri, 15 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/rest-api/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/rest-api/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>OSI 7계층</title>
        <description>&lt;p&gt;과거에는 통신용 규약이 표준화되지 읺았고 각 벤더에서 별도로 개발했기 때문에 호환되지 않는 시스템이나 애플리케이션이 많았고 통신이 불가능했다. 이를 하나의 규약으로 통합하려는 노력이 현재의 OSI 7계층으로 남게 되었고 대부분의 프로토콜이 TCP/IP 프로토콜 스택 기반으로 되어 있다.&lt;/p&gt;

&lt;p&gt;OSI 7계층은 두 가지 계층으로 나눌 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1~4 계층 : 데이터 플로 계층(Data Flow Layer) / 하위 계층(Lower Layer)&lt;/li&gt;
  &lt;li&gt;5~7 계층 : 애플리케이션 계층(Application Layer) / 상위 계층(Upper Layer)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1계층피지컬-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;1계층(피지컬 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1계층은 물리 계층으로 물리적 연결과 관련된 정보를 정의한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;주로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전기 신호를 전달하는데 초점이 맞추어져&lt;/code&gt; 있다.&lt;/p&gt;

&lt;p&gt;1계층에서는 들어온 전기 신호를 그대로 잘 전달하는 것이 목적이므로, 전기 신호가 1계층 장비에 들어오면 이 전기 신호를 재생성하여 내보낸다.&lt;/p&gt;

&lt;p&gt;주소의 개념이 없으므로, 전기 신호가 들어온 포트를 제외하고 모든 포트에 같은 전기 신호를 전송한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주요 장비 : 허브(hub), 리피터(Repeater), 케이블(Cable), 커넥터(Connector), 트랜시버(Tranceiver), 탭(TAP)
    &lt;ul&gt;
      &lt;li&gt;허브, 리피터 : 네트워크 통신을 중재하는 네트워크 장비&lt;/li&gt;
      &lt;li&gt;트랜시버 : 컴퓨터의 랜 카드와 케이블을 연결하는 장치&lt;/li&gt;
      &lt;li&gt;탭 : 네트워크 모니터링과 패킷 분석을 위해 전기 신호를 다른 장비로 복제함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2계층데이터-링크-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;2계층(데이터 링크 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;2계층은 데이터 링크 계층으로 전기 신호를 모아 우리가 알아볼 수 있는 데이터 형태로 처리한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;1계층과는 다르게 전기 신호를 정확히 전달하기보다는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주소 정보를 정의하고 정확한 주소로 통신이 되도록 하는 데 초점이 맞추어져&lt;/code&gt; 있다.&lt;/p&gt;

&lt;p&gt;출발지와 도착지 주소를 확인하고, 내게 보낸 것이 맞는지, 또는 내가 처리해야 하는지에 대해 검사한 후 데이터 처리를 수행한다.&lt;/p&gt;

&lt;p&gt;MAC주소라는 주소 체계가 있어 네트워크 인터페이스 카드와 스위치 모두 MAC 주소를 이해할 수 있고, 스위치는 MAC 주소를 보고 통신해야 할 포트를 지정해 내보내는 능력이 있다.&lt;/p&gt;

&lt;p&gt;동시에 여러 명과 통신하기 때문에 플로 컨트롤(Flow Control)을 수행한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/osi7layer/data-link.jpeg&quot; alt=&quot;img.png&quot; /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주요 장비 : 네트워크 인터페이스 카드, 스위치
    &lt;ul&gt;
      &lt;li&gt;네트워크 인터페이스 카드 : 자신에게 들어오는 전기 신호가 아니면 버리고, 맞으면 데이터를 메모리에 적재&lt;/li&gt;
      &lt;li&gt;스위치 : 주소 습득 과정을 통해 얻은 데이터를 기반으로 포트를 적절히 필터링하고, 정확한 포트로 포워딩&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/osi7layer/switch.jpeg&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3계층네트워크-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;3계층(네트워크 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;3계층에는 IP 주소와 같은 논리적인 주소가 정의된다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 통신을 할 떄는 2계층의 물리적인 MAC 주소와 3계층의 논리적인 IP 주소가 사용된다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3계층을 이해할 수 있는 장비나 단말은 네트워크 주소 정보를 이용해 자신이 속한 네트워크와 원격지 네트워크를 구분할 수 있고, 원격지 네트워크를 가려면 어디로 가야 하는지 경로를 지정한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주요 장비 : 라우터
    &lt;ul&gt;
      &lt;li&gt;라우터 : IP 주소를 사용해 최적의 경로를 찾고, 해당 경로로 패킷을 전송&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/osi7layer/router.jpeg&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;4계층트랜스포트-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;4계층(트랜스포트 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;4계층은 실제로 데이터들이 정상적으로 잘 보내지도록 확인하는 역할을 한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;패킷 네트워크는 데이터를 분할해 패킷에 실어보내다 보니 중간에 유실되거나, 순서가 뒤바뀔 수 있다. 이 문제를 바로 잡아주는 역할을 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;패킷에 보내는 순서를 명시하는 것이 시퀀스 번호이고, 받는 순서를 나타내는 것이 ACK 번호이다.&lt;/code&gt; 또한, 포트 번호를 사용해 상위 애플리케이션을 구분한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주요 장비 : 로드 밸런서, 방화벽
    &lt;ul&gt;
      &lt;li&gt;로드 밸런서 : 부하 분산&lt;/li&gt;
      &lt;li&gt;방화벽 : 패킷 통과 또는 차단&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;5계층세션-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;5계층(세션 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;5계층인 세션 계층은 양 끝단의 응용 프로세스가 연결을 성립하도록 도와주고 연결이 안정적으로 유지되도록 관리하며, 작업 완료 후에는 연결을 끊는 역할을 수행한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCP/IP 세션을 만들고 없애는 책임을 가지며, 에러로 중단된 통신에 대한 에러 복구와 재전송도 수행한다.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;6계층프레젠테이션-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;6계층(프레젠테이션 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;6계층인 프레젠테이션 계층은 표현 방시깅 다른 애플리케이션이나 시스템 간의 통신을 돕기 위해 하나의 통일된 구문 형식으로 변환시키는 기능을 수행한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;변환기 역할을 수행하는 계층으로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MIME 인코딩이나 암호화, 압축, 코드 변환과 같은 동작이 이루어진다.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;7계층애플리케이션-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;7계층(애플리케이션 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;7계층인 애플리케이션 계층은 애플리케이션 프로세스를 정의하고, 애플리케이션 서비를 수행한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;네트워크 소프트웨어의 UI 부분이나, 사용자 입/출력 부분을 정의하는 것이 애플리케이션 계층의 역할이다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;대표적인 프로토콜 : FTP, SMTP, HTTP, TELNET&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;계층별-주요-프로토콜-및-장비&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;계층별 주요 프로토콜 및 장비&lt;/span&gt;&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;계층&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;주요 프로토콜&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;장비&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;애플리케이션 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HTTP, SMP, SMTP, STUN, TFTP, TELNET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ADC, NGFW, WAF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;프레젠테이션 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TLS, AFP, SSH&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;세션 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;L2TP, PPTP, NFS, RPC, PTCP, SIP, SSH&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;트랜스포트 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TCP, UDP, SCTP, DCCP, AH, AEP&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;로드 밸런서, 방화벽&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;네트워크 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ARP, IPv4, IPv6, NATm IPSec, 라우팅 프로토콜&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;라우터, L3 스위치&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;데이터 링크 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;IEEE 802.2, FDDI&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;스위치, 브릿지, 네트워크 카드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;피지컬 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RS-232, RS-449, V.35, S 등의 케이블&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;케이블, 허브, 탭(TAP)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Fri, 15 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/network/osi7layer/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/network/osi7layer/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>network</category>
        
      </item>
    
      <item>
        <title>쿠버네티스(Kubernetes)</title>
        <description>&lt;p&gt;&lt;strong&gt;컨테이너 인프라 환경이란 리눅스 운영 체제의 커널 하나에서 여러 개의 컨테이너가 격리된 상태로 실행되는 인프라 환경을 말한다&lt;/strong&gt;. 여기서 컨테이너는 하나 이상의 목적을 위해 독립적으로 작동하는 프로세스를 뜻한다.&lt;/p&gt;

&lt;h2 id=&quot;컨테이너-오케스트레이션&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;컨테이너 오케스트레이션&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;실제로 쿠버네스트는 컨테이너 오케스트레이션을 위한 솔루션으로, &lt;strong&gt;오케스트레이션이란 복잡한 단계를 관리하고 요소들의 유기적인 관계를 미리 정의해 손쉽게 사용하도록 서비스를 제공하는 것을 뜻한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;다수의 컨테이너를 유기적으로 연결, 실행, 종료할 뿐만 아니라 상태를 추적하고 보존하는 등 컨테이너를 안정적으로 사용할 수 있게 만들어주는 것이 컨테이너 오케스트레이션이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;도커-스웜docker-swarm&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;도커 스웜(Docker Swarm)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;간단하게 설치할 수 있고 사용하기도 용이하다. 그러나 그만큼 기능이 다양하지 않아 대규모 환경에 적용하려면 사용자 환경을 변경해야 할 수 있다. 그리하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;소규모 환경에서는 유용하지만, 대규모 환경에서는 잘 사용하지 않는다.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;메소스mesos&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;메소스(Mesos)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;아파치의 오픈 소스 프로젝트로 역사와 전통이 있는 클러스터 도구이며 다양한 곳에서 충분히 검증된 솔루션이다. 메소스는 매우 간결하지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기능을 충분히 활용하려면 분산 관리 시스탬과 연동해야 하기 때문에 여러가지 솔루션을 유기적으로 구성해야 하는 부담이 있다.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;노매드nomad&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;노매드(Nomad)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;베어그런트를 만든 해시코프사의 컨테이너 오케스트레이션으로, 베이그런트처럼 간단한 구성으로 컨테이너 오케스트레이션 환경을 제공한다. 하지만 도커 스웜과 마찬가지로 기능이 부족하므로 복잡하게 여러 기능을 사용하는 환경이 아닌 가볍고 간단한 기능만 필요한 환경에서 사용하는 것이 좋다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;쿠버네티스kubernetes&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;쿠버네티스(Kubernetes)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;다른 오케스트레이션 솔루션보다는 시작하는 데 어려움이 있지만, 쉽게 사용할 수 있도록 도와주는 도구들이 있어서 설치가 쉬워지는 추세이다. 또 다양한 형태의 쿠버네티스가 지속적으로 계속 발전되고 있어 컨테이너 오케스트레이션을 넘어 IT 인프라 자체를 컨테이너화하고, 컨테이너화된 인프라 제품군을 쿠버네티스 위에서 동작할 수 있게 만든다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;컨테이너 오케스트레이션 솔루션 비교&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;도커 스윔&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;메소스&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;노매드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;쿠버네티스&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;설치 난이도&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용 편의성&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;세부 설정 지원&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;거의 없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;있음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;거의 없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;다양하게 있음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안정성&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 안정적임&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안정적임&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안정적엄&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 안정적임&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;확장성&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 잘 됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 잘 됨&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정보량&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;많음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 많음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;에코 파트너&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;거의 없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;있음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 많음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;학습 곡선&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;쿠버네티스-구성-방법&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;쿠버네티스 구성 방법&lt;/span&gt;&lt;/h6&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;퍼블릭 클라우드 업체에서 제공하는 &lt;strong&gt;관리형 쿠버네티스&lt;/strong&gt;인 EKS, AKS, GKE 등을 사용한다. 구성이 이미 갖춰져 있고 마스터 노드를 크라우드 업체에서 관리함으로 학습용으로는 부적합하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;수세의 Rancher, 레드햇의 OpenShift와 같은 플랫폼에서 제공하는 &lt;strong&gt;설치형 쿠버네티스&lt;/strong&gt;를 사용한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;허나 유료다.&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용하는 시스템에 쿠버네티스 클러스터를 &lt;strong&gt;자동으로 구성해주는 솔루션을 사용&lt;/strong&gt;한다. 주요 솔루션으로는 kubeadm, kops, KBIB, kubespray가 있다. 이 중 kubeadm이 가장 잘 알려져 있고, 사용자가 변경하기도 수월하며, 온프레미스와 클라우드를 모두 지원한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;쿠버네티스 클러스터 구성 솔루션 비교&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;도커 스윔&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;메소스&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;노매드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;쿠버네티스&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정보량&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;많음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;많음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 많음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;세부 설정 변경&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;가능함&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;가능함&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제한적으로 가능함&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;다양함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사전 요구 조건&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 적음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;온프레미스 지원&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라우드 지원&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안 됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;학습 곡선&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;자동화 기능&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제공됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제공됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽게 제공됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제한적으로 제공됨&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;파드를-배포할-때&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;파드를 배포할 때&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;쿠버네스트의 구성 요소의 유기적인 연결관계를 그림으로 표현하면 다음과 같다.&lt;br /&gt;
그림에 표시된 숫자는 실제로 관리자나 개발자가 파드 배포 명령을 수행했을 때 실행되는 순서다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes1.jpeg&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;h4 style=&quot;color:MediumSlateBlue&quot;&gt;마스터 노드&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;⓪. kubectl&lt;/strong&gt; : 쿠버네티스 클러스터에 명령을 내리는 역할을 한다. 다른 구성 요소들과 다르게 바로 실행되는 명령 형태인 바이너리(binary)로 배포되기 때문에 마스터 노드에 있을 필요는 없다. 허나, 통상적으로 API 서버와 주로 통신하므로 마스터 노드에 구성하였다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;①. API 서버&lt;/strong&gt; : 쿠버네티스 클러스터의 중심 역할을 하는 통로이다. 주로 상태 값을 저장하는 etcd와 통신하지만, 그 밖의 요소들 또한 API 서버를 중심에 두고 통신하므로 API 서버의 역할이 매우 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;②. etcd&lt;/strong&gt; : 구성 요소들의 상태 값이 모두 저장되는 곳이다. 회사의 관리자가 모든 보고 내용을 기록하는 노트라고 생각하면 된다. 실제로 etcd 외의 다른 구성 요소는 상태 값을 관리하지 않는다. 그러므로 etcd의 정보만 백업되어 있다면 장애 상황에서도 쿠버네티스 클러스터는 복구할 수 있다. 또한 etcd는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;분산 저장이 가능한 key-value 저장소&lt;/code&gt;이므로, 복제해 여러 곳에 저장해 두면 하나의 etcd에서 장애가 나더라도 시스템의 가용성을 확보할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;③. 컨트롤러 매니저&lt;/strong&gt; : 컨트롤러 매니저는 쿠버네티스 클러스터의 오브젝트 상태를 관리한다. 예를 들어 워커 노드에서 통신이 되지 않는 경우, 상태 체크와 복구는 컨트롤러 매니어제 속한 노드 컨트롤러에서 이뤄진다. 다양한 상태 값을 관리하는 주체들이 컨트롤러 매니저에 소속되어 각자의 역할을 수행한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;④. 스케줄러&lt;/strong&gt; : 노드의 상태와 자원, 레이블, 요구 조건 등을 고려해 파드를 어떤 워커 노드에 생성할 것인지를 결정하고 할당한다. 스케줄러라는 이름에 맞게 파드를 조건에 맞는 워커 노드에 지정하고, 파드가 워커 노드에 할당되는 일정을 관리한다.&lt;/p&gt;

&lt;h4 style=&quot;color:MediumSlateBlue&quot;&gt;워커 노드&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;⑤. kubelet&lt;/strong&gt; : 파드의 구성 내용(PodSpec)을 받아서 컨테이너 런타임으로 전달하고, 파드 안의 컨테이너들이 정상적으로 작동하는지 모니터링 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;⑥. 컨테이너 런타임(CRI)&lt;/strong&gt; : 파드를 이루는 컨테이너의 실행을 담당한다. 파드 안에서 다양한 종류의 컨테이너가 문제 없이 작동하게 만드는 표준 인터페이스이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;⑦. 파드(Pod)&lt;/strong&gt; : 한 개 이상의 컨테이너로 단일 목적의 일을 하기 위해서 모인 단위이다. 즉, 웹서버 역할을 할 수도 있고 로그나 데이터를 분석할 수도 있다. 중요한 것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;파드는 언제라도 죽을 수 있는 존재라는 점&lt;/code&gt;이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
조훈·심근우·문성주 (2021). 컨테이너 인프라 환경 구축을 위한 쿠버네티스/도커. 길벗&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/docker-kubernetes/kuberbetes/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/docker-kubernetes/kuberbetes/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>Docker-Kubernetes</category>
        
      </item>
    
  </channel>
</rss>