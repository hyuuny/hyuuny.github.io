<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  
  <channel>
    <title> Hyuuny`s Blog  </title>
    <description>객체지향과 DDD에 관심이 많은 백엔드개발자로서, 최근에는 리눅스와 도커에 관심이 생겨 함께 공부하고 있습니다.</description>
    <link>https://hyuuny.github.io/</link>
    <atom:link href="https://hyuuny.github.io/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Wed, 27 Oct 2021 22:38:18 +0900</pubDate>
    <lastBuildDate>Wed, 27 Oct 2021 22:38:18 +0900</lastBuildDate>
    <generator>Jekyll v4.2.0</generator>
    
      <item>
        <title>IoC, DI, Container</title>
        <description>&lt;h2 id=&quot;제어의-역전inversion-of-control&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;제어의 역전(Inversion of Control)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;기존 프로그램은 클라이언트 구현 객체가 스스로 필요한 서버 구현 객체를 생성하고, 연결하고, 실행했다. 한마디로 구현 객체가 프로그램의 제어 흐름을 스스로 조종했다.&lt;/li&gt;
  &lt;li&gt;AppConfig가 등장한 이후에 구현 객체는 자신의 로직을 실행하는 역할만 담당한다. 프로그램의 제어 흐름은 이제 AppConfig가 가져간다.
    &lt;ul&gt;
      &lt;li&gt;예를 들어서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt; 은 필요한 인터페이스들(&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;repository&lt;/code&gt;와 같은)을 호출하지만 어떤 구현 객체들이 실행될지 모른다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;프로그램에 대한 제어 흐름에 대한 권한은 모두 AppConfig가 가지고 있다. 심지어 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt;도 AppConfig가 생성한다.
    &lt;ul&gt;
      &lt;li&gt;AppConfig는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt; 이 아닌 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderService&lt;/code&gt; 인터페이스의 다른 구현 객체를 생성하고 실행할 수 도 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;이렇듯 프로그램의 &lt;strong&gt;제어 흐름을 직접 제어하는 것이 아니라 외부에서 관리하는 것을 제어의 역전(IoC)&lt;/strong&gt;이라 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;프레임워크와 라이브러리&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;프레임워크가 내가 작성한 코드를 제어하고, 대신 실행하면 프레임워크이다.&lt;/li&gt;
  &lt;li&gt;내가 작성한 코드가 직접 제어의 흐름을 담당한다면 프레임워크가 아니라 라이브러리다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;의존관계-주입-didependency-injection&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;의존관계 주입 DI(Dependency Injection)&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderServiceImpl&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;implements&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;final&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DiscountPolicy&lt;/code&gt; 인터페이스에 의존한다. 실제 어떤 구현 객체가 사용될지는
모른다.&lt;/li&gt;
  &lt;li&gt;의존관계는 &lt;strong&gt;정적인 클래스 의존 관계&lt;/strong&gt;와, &lt;strong&gt;실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계&lt;/strong&gt; 둘을 분리해서 생각해야 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;정적인 클래스 의존관계&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;클래스가 사용하는 import 코드만 보고 의존관계를 쉽게 판단할 수 있다. 정적인 의존관계는 애플리케이션을 실행하지 않아도 분석할 수 있다.&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt;은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MemberRepository&lt;/code&gt; , &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;DiscountPolicy&lt;/code&gt;에 의존한다는 것을 알 수 있다.
그런데 이러한 클래스 의존관계 만으로는 실제 어떤 객체가 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;OrderServiceImpl&lt;/code&gt;에 주입 될지 알 수 없다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/di1.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;동적인 객체 인스턴스 의존 관계&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;애플리케이션 실행 시점에&lt;/strong&gt; 실제 생성된 객체 인스턴스의 참조가 연결된 의존 관계다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/di2.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;애플리케이션 &lt;strong&gt;실행 시점(런타임)&lt;/strong&gt;에 외부에서 실제 구현 객체를 생성하고 클라이언트에 전달해서 클라이언트와 서버의 실제 의존관계가 연결 되는 것을 &lt;strong&gt;의존관계 주입&lt;/strong&gt;이라 한다.&lt;/li&gt;
  &lt;li&gt;객체 인스턴스를 생성하고, 그 참조값을 전달해서 연결된다.&lt;/li&gt;
  &lt;li&gt;의존관계 주입을 사용하면 클라이언트 코드를 변경하지 않고, 클라이언트가 호출하는 대상의 타입 인스턴스를 변경할 수 있다.&lt;/li&gt;
  &lt;li&gt;의존관계 주입을 사용하면 &lt;strong&gt;정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경&lt;/strong&gt;할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;ioc-컨테이너-di-컨테이너&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;IoC 컨테이너, DI 컨테이너&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;AppConfig 처럼 &lt;strong&gt;객체를 생성하고 관리하면서 의존관계를 연결해 주는 것을 IoC 컨테이너 또는 DI 컨테이너&lt;/strong&gt;라 한다.&lt;/li&gt;
  &lt;li&gt;의존관계 주입에 초점을 맞추어 &lt;strong&gt;최근에는 주로 DI 컨테이너&lt;/strong&gt;라 한다.&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/IoC-DI-Container/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/IoC-DI-Container/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>ApplicationContext</title>
        <description>&lt;h2 id=&quot;config-기반-bean-설정&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;Config 기반 Bean 설정&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;nd&quot;&gt;@Configuration&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;memberService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MemberServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;MemoryMemberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;OrderService&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;orderService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;OrderServiceImpl&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(),&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;discountpolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

  &lt;span class=&quot;nd&quot;&gt;@Bean&lt;/span&gt;
  &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;DiscountPolicy&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;discountpolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;RateDiscountPolicy&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
  &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;AppConfig에 설정을 구성한다는 뜻의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Configuration&lt;/code&gt;을 붙여준다.&lt;/li&gt;
  &lt;li&gt;각 메서드에 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;을 붙여준다. 이렇게 하면 &lt;strong&gt;메서드에서 반환하는 객체를 스프링 컨테이너에 스프링 빈으로 등록&lt;/strong&gt;한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;스프링-컨테이너에-등록한-bean-꺼내서-사용하기&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;스프링 컨테이너에 등록한 Bean 꺼내서 사용하기&lt;/span&gt;&lt;/h2&gt;
&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// parameter : @Coufiguration이 붙은 구성 클래스&lt;/span&gt;
 &lt;span class=&quot;nc&quot;&gt;ApplicationContext&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;applicationContext&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;AnnotationConfigApplicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nc&quot;&gt;AppConfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; 
&lt;span class=&quot;c1&quot;&gt;// parameter : 빈이름, 반환타입&lt;/span&gt;
&lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;applicationContext&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getBean&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;memberService&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;class&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);/&lt;/span&gt;

&lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;member&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1L&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;memberA&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Grade&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;VIP&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;memberService&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;member&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;ApplicationContext를 스프링 컨테이너&lt;/strong&gt;라 한다.&lt;/li&gt;
  &lt;li&gt;기존에는 개발자가 AppConfig 를 사용해서 직접 객체를 생성하고 DI를 했지만, 이제부터는 스프링 컨테이너를 통해서 사용한다.&lt;/li&gt;
  &lt;li&gt;스프링 컨테이너는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Configuration&lt;/code&gt;이 붙은 AppConfig 를 설정(구성) 정보로 사용한다. 여기서 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;이라 적힌 메서드를 모두 호출해서 반환된 객체를 스프링 컨테이너에 등록한다. 이렇게 &lt;strong&gt;스프링 컨테이너에 등록된 객체를 스프링 빈&lt;/strong&gt;이라 한다.&lt;/li&gt;
  &lt;li&gt;스프링 빈은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;이 붙은 &lt;strong&gt;메서드의 명을 스프링 빈의 이름으로 사용&lt;/strong&gt;한다.&lt;/li&gt;
  &lt;li&gt;이전에는 개발자가 필요한 객체를 AppConfig 를 사용해서 직접 조회했지만, 이제부터는 스프링 컨테이너를 통해서 필요한 스프링 빈(객체)를 찾아야 한다. 스프링 빈은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;applicationContext.getBean()&lt;/code&gt; 메서드를 사용해서 찾을 수 있다.&lt;/li&gt;
  &lt;li&gt;기존에는 개발자가 직접 자바코드로 모든 것을 했다면 이제부터는 스프링 컨테이너에 객체를 스프링 빈으로 등록하고, 스프링 컨테이너에서 스프링 빈을 찾아서 사용하도록 변경되었다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/spring-context.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 부트 실행 시, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;@Bean&lt;/code&gt;이 만들어지는 모습&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;스프링-컨테이너-생성-과정&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;스프링 컨테이너 생성 과정&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너는 XML(거의 사용 안 함)을 기반으로 만들 수 있고, 애노테이션 기반의 자바 설정 클래스로 만들 수 있다.&lt;/li&gt;
  &lt;li&gt;더 정확하게는 스프링 컨테이너를 부를 때 BeanFactory , ApplicationContext 로 구분하지만,  BeanFactory 를 직접 사용하는 경우는 거의 없으므로 일반적으로 ApplicationContext 를 스프링 컨테이너라 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;1. 스프링 컨테이너 생성&lt;/strong&gt;
&lt;img src=&quot;/assets/images/spring/application-context1.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너를 생성할 때는 구성 정보(여기서는 AppConfig.class)를 지정해줘야 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;2. 스프링 빈 등록&lt;/strong&gt;
&lt;img src=&quot;/assets/images/spring/application-context2.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너는 파라미터 넘어온 설정 클래스 정보를 읽어, @Bean 으로 등록된 메서드의 반환 타입을 스프링의 빈으로 등록한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;3. 스프링 빈 의존관계 설정 - 준비&lt;/strong&gt;
&lt;img src=&quot;/assets/images/spring/application-context3.png&quot; alt=&quot;img.png&quot; /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;4. 스프링 빈 의존관계 설정 - 완료&lt;/strong&gt;
&lt;img src=&quot;/assets/images/spring/application-context4.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너는 설정 정보를 참고하여 의존관계를 주입(DI)한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;beanfactory와-applicationcontext&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;BeanFactory와 ApplicationContext&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;/assets/images/spring/application-context5.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;beanfactory&quot;&gt;&lt;strong&gt;BeanFactory&lt;/strong&gt;&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;스프링 컨테이너의 최상위 인터페이스다.&lt;/li&gt;
  &lt;li&gt;스프링 빈을 관리하고 조회하는 역할을 담당한다.&lt;/li&gt;
  &lt;li&gt;getBean() 을 제공한다.&lt;/li&gt;
  &lt;li&gt;지금까지 우리가 사용했던 대부분의 기능은 BeanFactory가 제공하는 기능이다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/spring/application-context6.png&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;h6 id=&quot;applicationcontext&quot;&gt;&lt;strong&gt;ApplicationContext&lt;/strong&gt;&lt;/h6&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;BeanFactory 기능을 모두 상속받아서 제공한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;메시지소스를 활용한 국제화 기능(MessageSource)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;한국에서 들어오면 한국어로, 영어권에서 들어오면 영어로 출력&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;환경변수(EnvironmentCapable)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;로컬, 개발, 운영등을 구분해서 처리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;애플리케이션 이벤트(ApplicationEventPublisher)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;이벤트를 발행하고 구독하는 모델을 편리하게 지원&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;편리한 리소스 조회(ResourceLoader)&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;파일, 클래스패스, 외부 등에서 리소스를 편리하게 조회&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Mon, 25 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/ApplicationContext/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/ApplicationContext/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>SOLID 원칙</title>
        <description>&lt;p&gt;클린코드로 유명한 로버트 마틴이 &lt;strong&gt;좋은 객체 지향 설계의 5가지 원칙&lt;/strong&gt;을 정리하였다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;SRP: 단일 책임 원칙(Single Responsibility Principle)&lt;/li&gt;
  &lt;li&gt;OCP: 개방-폐쇄 원칙(Opne Closed Principle)&lt;/li&gt;
  &lt;li&gt;LSP: 리스코프 치환 원칙(Liskov Substitution Principle)&lt;/li&gt;
  &lt;li&gt;ISP: 인터페이스 분리 원칙(Interface Segregation Principle)&lt;/li&gt;
  &lt;li&gt;DIP: 의존관계 역전 원칙(Dependency Inversion Principle)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;srp-단일-책임-원칙single-responsibility-principle&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;SRP 단일 책임 원칙(Single Responsibility Principle)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;한 클래스는 하나의 책임&lt;/strong&gt;을 가져야 한다.&lt;/li&gt;
  &lt;li&gt;하나의 책임이라는 기준은 모호하다.
    &lt;ul&gt;
      &lt;li&gt;클 수도 있고, 작을 수도 있다.&lt;/li&gt;
      &lt;li&gt;문맥과 상황에 따라 다르다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;중요한 기준은 변경&lt;/strong&gt;이다. 변경이 있을 때, 파급효과가 적으면 단일 책임원칙을 잘 따른 것
    &lt;ul&gt;
      &lt;li&gt;예) UI 변경, 객체의 생성과 사용을 분리&lt;/li&gt;
    &lt;/ul&gt;

    &lt;hr /&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ocp-개방-폐쇄-원칙opne-closed-principle&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;OCP 개방-폐쇄 원칙(Opne Closed Principle)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;소프트웨어 요소는 &lt;strong&gt;확장에는 열려&lt;/strong&gt;있으나, &lt;strong&gt;변경에는 닫혀&lt;/strong&gt;있어야 한다.&lt;/li&gt;
  &lt;li&gt;다형성을 활용하자.(역할과 구현을 분리)&lt;/li&gt;
  &lt;li&gt;인터페이스를 구현한 새로운 클래스를 하나 만들어서 새로운 기능을 구현하자.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;예시&lt;/span&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Service 의존하고 있는 MemberReposiroty를 JdbcMEmberReposiroty로 변경해야 하는 상황.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-java highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberService&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;c1&quot;&gt;//private MemberRepository memberRepository = new MemberRepository(); // 기존코드&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;MemberRepository&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;memberRepository&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;JdbcMemberReposiroty&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// 변경 코드&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;구현 객체를 변경하면 클라이언트 코드를 변경해야한다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;분명 다형성을 사용했지만, OCP 원칙을 지킬 수 없다.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;객체를 생성하고, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
    &lt;ul&gt;
      &lt;li&gt;여기서는 &lt;strong&gt;MemberReposiroty를 인터페이스로 두고, 이를 구현&lt;/strong&gt;하도록 하자.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Service는 Repository 인터페이스만 바라봄으로써, Repository의 &lt;strong&gt;구현체가 무엇이든 상관 없다.&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;lsp-리스코프-치환-원칙liskov-substitution-principle&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;LSP 리스코프 치환 원칙(Liskov Substitution Principle)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로그램의 객체는 &lt;strong&gt;프로그램의 정확성을 깨드리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야&lt;/strong&gt; 한다.&lt;/li&gt;
  &lt;li&gt;다형성에서
    &lt;ul&gt;
      &lt;li&gt;하위 클래스는 인터페이스 규약을 다 지켜야 한다는 것,&lt;/li&gt;
      &lt;li&gt;다형성을 지원하기 위한 원칙,&lt;/li&gt;
      &lt;li&gt;인터페이스를 구현한 구현체는 믿고 사용하려면 이 원칙이 필요하다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;단순히 컴파일에 성공한다고 다가 아니다.
    &lt;ul&gt;
      &lt;li&gt;예) 자동차 인터페이스의 엑셀은 앞으로 가는 기능
        &lt;ul&gt;
          &lt;li&gt;뒤로 가도록 구현하면 LSP 위반&lt;/li&gt;
          &lt;li&gt;느리더라도 앞으로 가야 한다.&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;isp-인터페이스-분리-원칙interface-segregation-principle&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;ISP 인터페이스 분리 원칙(Interface Segregation Principle)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;특정 클라이언트를 위한 인터페이스 &lt;strong&gt;여러 개가 범용 인터페이스 하나보다 낫다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;예) 자동차 인터페이스 -&amp;gt; 운전 인터페이스, 정비 인터페이스로 분리&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;분리하면 정비 인터페이스 자체가 변해도 운전자 클라이언트에 영향을 주지 않음.&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;인터페이스가 명확해지고, 대체 가능성이 높아&lt;/strong&gt;진다.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;dip-의존관계-역전-원칙dependency-inversion-principle&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;DIP 의존관계 역전 원칙(Dependency Inversion Principle)&lt;/span&gt;&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;프로그래머는 &lt;strong&gt;“추상화에 의존해야지, 구체화에 의존하면 안된다.” 의존성 주입은 이 원칙을 따르는 방법 중 하나&lt;/strong&gt;다.
    &lt;ul&gt;
      &lt;li&gt;&lt;strong&gt;구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻&lt;/strong&gt;
&lt;strong&gt;역할(Role)에 의존하게 해야 한다는 것과 같다.&lt;/strong&gt; (구현에 의존하지 말자!)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;클라이언트가 &lt;strong&gt;인터페이스에 의존하야 유연하게 구현체를 변경할 수 있다.&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;구현체에 의존하게 되면 변경이 아주 어려워진다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sun, 24 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/SOLID/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/SOLID/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>REST API란</title>
        <description>&lt;p&gt;REST는 Representational State Transfer의 약자로 아키텍처 스타일이다. 아키텍처 스타일은 아키텍처 패턴과는 조금 다른데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;아키텍처 패턴은 어떤 반복되는 문제 상황을 해결하는 도구&lt;/code&gt;이고, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;아키텍처 스타일은 반복되는 아키텍처 디자인을 의미&lt;/code&gt;한다.&lt;br /&gt;
&lt;strong&gt;REST 아키텍처 스타일은 6가지 제약조건으로 구성되며, 이 가이드 라인을 따르는 API를 RESTfull API&lt;/strong&gt;라고 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;REST 제약 조건&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;클라이언트-서버(Client-Server)&lt;/li&gt;
  &lt;li&gt;상태가 없는(stateless)&lt;/li&gt;
  &lt;li&gt;캐시되는 데이터(Cacheable)&lt;/li&gt;
  &lt;li&gt;일관적인 인터페이스(Uniform Interface)&lt;/li&gt;
  &lt;li&gt;레이어 시스템(Layered System)&lt;/li&gt;
  &lt;li&gt;코드-온-디맨트(Code-On-Demand)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;클라이언트-서버client-server&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;클라이언트-서버(Client-Server)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;클라이언트-서버는 리소스를 관리하는 서버가 존재하고, 다수의 클라이언트가 리소스를 소비하려고 네트워크를 통해 서버에 접근하는 구조를 말한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;이런 구조 중 우리에게 가장 친숙한 것이 바로 웹 애플리케이션이다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;리소스란 REST API가 리턴할 수 있는 모든 것(HTML, JSON, 이미지 등)을 의미한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;상태가-없는stateless&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;상태가 없는(stateless)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;상태가 없다는 것은 클라이언트가 서버에 요청을 보낼 때, 이전 요청의 영향을 받지 않음을 의미한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 로그인의 경우 서버는 로그인 상태를 유지하지 못하므로, 요청을 보낼 때마다 로그인 정보를 항상 함께 보내야 한다. 리소스를 수정한 후 수정한 상태를 유지해야 하는 경우에는 서버가 아닌 DB와 같은 곳에 상태를 저장해야한다.&lt;/p&gt;

&lt;p&gt;HTTP는 기본적으로 상테가 없는 프로토콜이다. 따라서 HTTP를 사용하는 웹 애플리케이션은 기본적으로 상태가 없는 구조를 따른다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;캐시되는-데이터cacheable&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;캐시되는 데이터(Cacheable)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;서버에서 리소스를 리턴할 때 캐시가 가능한지 아닌지 명시할 수 있어야 한다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;HTTP에서는 cache-control이라는 헤더에 리소스의 캐시 여부를 명시할 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;일관적인-인터페이스uniform-interface&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;일관적인 인터페이스(Uniform Interface)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;일관적인 인터페이스란, 시스템 또는 애플리케이션의 리소스에 접근할 때 인터페이스가 일관적이어야 한다는 뜻이다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 어떤 정보를 가져오기 위해 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://example.com/water&lt;/code&gt;를 사용했다고 하자. 이때 정보를 업데이트 하는 데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://example2.com/water&lt;/code&gt;를 사용한다면 이것은 URI의 일관성이 있다고 볼 수 없다.&lt;/p&gt;

&lt;p&gt;또 다른 예로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://example.com/water&lt;/code&gt;는 JSON 형식의 리소스를 리턴했다. 그런데 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;http://example.com/book&lt;/code&gt;은 HTML을 리턴했다. 이런 인터페이스는 타입에 일관성이 있다고 볼 수 없다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;요청의 형태와 응답의 형태가 애플리케이션 전반에 걸쳐 일관적이어야 한다는 것이 일관적인 인터페이스 방침이다&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;레이어-시스템layered-system&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;레이어 시스템(Layered System)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;클라이언트가 서버에 요청을 할 때, 여러 개의 레이어로 된 서버를 거칠 수 있다.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;예를 들어 서버가 인증 서버, 캐싱 서커, 로드 밸런서를 거쳐서 최종적으로 애플리케이션에 도착한다고 가정하자. &lt;strong&gt;이 사이의 레이어들은 요청과 응답에 어떤 영향을 미치지 않으며, 클라이언트는 레이어 존재 유무를 알지 못한다&lt;/strong&gt;.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;코드-온-디맨트code-on-demand&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;코드-온-디맨트(Code-On-Demand)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;클라이언트는 서버에 코드를 요청할 수 있고, 서버가 리턴한 코드를 실행할 수 있다.(선택 사항)&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;REST는 HTTP와 다르다. REST는 HTTP를 이용해 구현하기 쉽고 대부분 그렇게 구현하지만, &lt;strong&gt;REST는 아키텍처&lt;/strong&gt;이고, &lt;strong&gt;HTTP는 REST 아키텍처를 구현할 때 사용하면 쉬운 프로토콜&lt;/strong&gt;이다.&lt;/p&gt;

</description>
        <pubDate>Fri, 15 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/spring/rest-api/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/spring/rest-api/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>spring</category>
        
      </item>
    
      <item>
        <title>OSI 7계층</title>
        <description>&lt;p&gt;과거에는 통신용 규약이 표준화되지 읺았고 각 벤더에서 별도로 개발했기 때문에 호환되지 않는 시스템이나 애플리케이션이 많았고 통신이 불가능했다. 이를 하나의 규약으로 통합하려는 노력이 현재의 OSI 7계층으로 남게 되었고 대부분의 프로토콜이 TCP/IP 프로토콜 스택 기반으로 되어 있다.&lt;/p&gt;

&lt;p&gt;OSI 7계층은 두 가지 계층으로 나눌 수 있다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;1~4 계층 : 데이터 플로 계층(Data Flow Layer) / 하위 계층(Lower Layer)&lt;/li&gt;
  &lt;li&gt;5~7 계층 : 애플리케이션 계층(Application Layer) / 상위 계층(Upper Layer)&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;1계층피지컬-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;1계층(피지컬 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;1계층은 물리 계층으로 물리적 연결과 관련된 정보를 정의한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;주로 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;전기 신호를 전달하는데 초점이 맞추어져&lt;/code&gt; 있다.&lt;/p&gt;

&lt;p&gt;1계층에서는 들어온 전기 신호를 그대로 잘 전달하는 것이 목적이므로, 전기 신호가 1계층 장비에 들어오면 이 전기 신호를 재생성하여 내보낸다.&lt;/p&gt;

&lt;p&gt;주소의 개념이 없으므로, 전기 신호가 들어온 포트를 제외하고 모든 포트에 같은 전기 신호를 전송한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주요 장비 : 허브(hub), 리피터(Repeater), 케이블(Cable), 커넥터(Connector), 트랜시버(Tranceiver), 탭(TAP)
    &lt;ul&gt;
      &lt;li&gt;허브, 리피터 : 네트워크 통신을 중재하는 네트워크 장비&lt;/li&gt;
      &lt;li&gt;트랜시버 : 컴퓨터의 랜 카드와 케이블을 연결하는 장치&lt;/li&gt;
      &lt;li&gt;탭 : 네트워크 모니터링과 패킷 분석을 위해 전기 신호를 다른 장비로 복제함&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;2계층데이터-링크-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;2계층(데이터 링크 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;2계층은 데이터 링크 계층으로 전기 신호를 모아 우리가 알아볼 수 있는 데이터 형태로 처리한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;1계층과는 다르게 전기 신호를 정확히 전달하기보다는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;주소 정보를 정의하고 정확한 주소로 통신이 되도록 하는 데 초점이 맞추어져&lt;/code&gt; 있다.&lt;/p&gt;

&lt;p&gt;출발지와 도착지 주소를 확인하고, 내게 보낸 것이 맞는지, 또는 내가 처리해야 하는지에 대해 검사한 후 데이터 처리를 수행한다.&lt;/p&gt;

&lt;p&gt;MAC주소라는 주소 체계가 있어 네트워크 인터페이스 카드와 스위치 모두 MAC 주소를 이해할 수 있고, 스위치는 MAC 주소를 보고 통신해야 할 포트를 지정해 내보내는 능력이 있다.&lt;/p&gt;

&lt;p&gt;동시에 여러 명과 통신하기 때문에 플로 컨트롤(Flow Control)을 수행한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/osi7layer/data-link.jpeg&quot; alt=&quot;img.png&quot; /&gt;&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주요 장비 : 네트워크 인터페이스 카드, 스위치
    &lt;ul&gt;
      &lt;li&gt;네트워크 인터페이스 카드 : 자신에게 들어오는 전기 신호가 아니면 버리고, 맞으면 데이터를 메모리에 적재&lt;/li&gt;
      &lt;li&gt;스위치 : 주소 습득 과정을 통해 얻은 데이터를 기반으로 포트를 적절히 필터링하고, 정확한 포트로 포워딩&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/osi7layer/switch.jpeg&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;3계층네트워크-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;3계층(네트워크 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;3계층에는 IP 주소와 같은 논리적인 주소가 정의된다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;데이터 통신을 할 떄는 2계층의 물리적인 MAC 주소와 3계층의 논리적인 IP 주소가 사용된다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;3계층을 이해할 수 있는 장비나 단말은 네트워크 주소 정보를 이용해 자신이 속한 네트워크와 원격지 네트워크를 구분할 수 있고, 원격지 네트워크를 가려면 어디로 가야 하는지 경로를 지정한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주요 장비 : 라우터
    &lt;ul&gt;
      &lt;li&gt;라우터 : IP 주소를 사용해 최적의 경로를 찾고, 해당 경로로 패킷을 전송&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/network/osi7layer/router.jpeg&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;4계층트랜스포트-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;4계층(트랜스포트 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;4계층은 실제로 데이터들이 정상적으로 잘 보내지도록 확인하는 역할을 한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;패킷 네트워크는 데이터를 분할해 패킷에 실어보내다 보니 중간에 유실되거나, 순서가 뒤바뀔 수 있다. 이 문제를 바로 잡아주는 역할을 한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;패킷에 보내는 순서를 명시하는 것이 시퀀스 번호이고, 받는 순서를 나타내는 것이 ACK 번호이다.&lt;/code&gt; 또한, 포트 번호를 사용해 상위 애플리케이션을 구분한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;주요 장비 : 로드 밸런서, 방화벽
    &lt;ul&gt;
      &lt;li&gt;로드 밸런서 : 부하 분산&lt;/li&gt;
      &lt;li&gt;방화벽 : 패킷 통과 또는 차단&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;5계층세션-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;5계층(세션 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;5계층인 세션 계층은 양 끝단의 응용 프로세스가 연결을 성립하도록 도와주고 연결이 안정적으로 유지되도록 관리하며, 작업 완료 후에는 연결을 끊는 역할을 수행한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;TCP/IP 세션을 만들고 없애는 책임을 가지며, 에러로 중단된 통신에 대한 에러 복구와 재전송도 수행한다.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;6계층프레젠테이션-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;6계층(프레젠테이션 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;6계층인 프레젠테이션 계층은 표현 방시깅 다른 애플리케이션이나 시스템 간의 통신을 돕기 위해 하나의 통일된 구문 형식으로 변환시키는 기능을 수행한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;변환기 역할을 수행하는 계층으로, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;MIME 인코딩이나 암호화, 압축, 코드 변환과 같은 동작이 이루어진다.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;7계층애플리케이션-계층&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;7계층(애플리케이션 계층)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;7계층인 애플리케이션 계층은 애플리케이션 프로세스를 정의하고, 애플리케이션 서비를 수행한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;네트워크 소프트웨어의 UI 부분이나, 사용자 입/출력 부분을 정의하는 것이 애플리케이션 계층의 역할이다.&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;대표적인 프로토콜 : FTP, SMTP, HTTP, TELNET&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;계층별-주요-프로토콜-및-장비&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;계층별 주요 프로토콜 및 장비&lt;/span&gt;&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;계층&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;주요 프로토콜&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;장비&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;애플리케이션 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HTTP, SMP, SMTP, STUN, TFTP, TELNET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ADC, NGFW, WAF&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;프레젠테이션 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TLS, AFP, SSH&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;세션 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;L2TP, PPTP, NFS, RPC, PTCP, SIP, SSH&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt; &lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;트랜스포트 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TCP, UDP, SCTP, DCCP, AH, AEP&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;로드 밸런서, 방화벽&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;네트워크 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;ARP, IPv4, IPv6, NATm IPSec, 라우팅 프로토콜&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;라우터, L3 스위치&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;데이터 링크 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;IEEE 802.2, FDDI&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;스위치, 브릿지, 네트워크 카드&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;피지컬 계층&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;RS-232, RS-449, V.35, S 등의 케이블&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;케이블, 허브, 탭(TAP)&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

</description>
        <pubDate>Fri, 15 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/network/osi7layer/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/network/osi7layer/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>network</category>
        
      </item>
    
      <item>
        <title>쿠버네티스(Kubernetes)</title>
        <description>&lt;p&gt;&lt;strong&gt;컨테이너 인프라 환경이란 리눅스 운영 체제의 커널 하나에서 여러 개의 컨테이너가 격리된 상태로 실행되는 인프라 환경을 말한다&lt;/strong&gt;. 여기서 컨테이너는 하나 이상의 목적을 위해 독립적으로 작동하는 프로세스를 뜻한다.&lt;/p&gt;

&lt;h2 id=&quot;컨테이너-오케스트레이션&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;컨테이너 오케스트레이션&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;실제로 쿠버네스트는 컨테이너 오케스트레이션을 위한 솔루션으로, &lt;strong&gt;오케스트레이션이란 복잡한 단계를 관리하고 요소들의 유기적인 관계를 미리 정의해 손쉽게 사용하도록 서비스를 제공하는 것을 뜻한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;다수의 컨테이너를 유기적으로 연결, 실행, 종료할 뿐만 아니라 상태를 추적하고 보존하는 등 컨테이너를 안정적으로 사용할 수 있게 만들어주는 것이 컨테이너 오케스트레이션이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;도커-스웜docker-swarm&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;도커 스웜(Docker Swarm)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;간단하게 설치할 수 있고 사용하기도 용이하다. 그러나 그만큼 기능이 다양하지 않아 대규모 환경에 적용하려면 사용자 환경을 변경해야 할 수 있다. 그리하여 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;소규모 환경에서는 유용하지만, 대규모 환경에서는 잘 사용하지 않는다.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;메소스mesos&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;메소스(Mesos)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;아파치의 오픈 소스 프로젝트로 역사와 전통이 있는 클러스터 도구이며 다양한 곳에서 충분히 검증된 솔루션이다. 메소스는 매우 간결하지만, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;기능을 충분히 활용하려면 분산 관리 시스탬과 연동해야 하기 때문에 여러가지 솔루션을 유기적으로 구성해야 하는 부담이 있다.&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;노매드nomad&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;노매드(Nomad)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;베어그런트를 만든 해시코프사의 컨테이너 오케스트레이션으로, 베이그런트처럼 간단한 구성으로 컨테이너 오케스트레이션 환경을 제공한다. 하지만 도커 스웜과 마찬가지로 기능이 부족하므로 복잡하게 여러 기능을 사용하는 환경이 아닌 가볍고 간단한 기능만 필요한 환경에서 사용하는 것이 좋다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;쿠버네티스kubernetes&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;쿠버네티스(Kubernetes)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;다른 오케스트레이션 솔루션보다는 시작하는 데 어려움이 있지만, 쉽게 사용할 수 있도록 도와주는 도구들이 있어서 설치가 쉬워지는 추세이다. 또 다양한 형태의 쿠버네티스가 지속적으로 계속 발전되고 있어 컨테이너 오케스트레이션을 넘어 IT 인프라 자체를 컨테이너화하고, 컨테이너화된 인프라 제품군을 쿠버네티스 위에서 동작할 수 있게 만든다.&lt;/p&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;컨테이너 오케스트레이션 솔루션 비교&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;도커 스윔&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;메소스&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;노매드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;쿠버네티스&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;설치 난이도&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용 편의성&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;세부 설정 지원&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;거의 없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;있음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;거의 없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;다양하게 있음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안정성&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 안정적임&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안정적임&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안정적엄&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 안정적임&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;확장성&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 잘 됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 잘 됨&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정보량&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;많음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 많음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;에코 파트너&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;거의 없음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;있음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 많음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;학습 곡선&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;쿠버네티스-구성-방법&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;쿠버네티스 구성 방법&lt;/span&gt;&lt;/h6&gt;
&lt;ol&gt;
  &lt;li&gt;
    &lt;p&gt;퍼블릭 클라우드 업체에서 제공하는 &lt;strong&gt;관리형 쿠버네티스&lt;/strong&gt;인 EKS, AKS, GKE 등을 사용한다. 구성이 이미 갖춰져 있고 마스터 노드를 크라우드 업체에서 관리함으로 학습용으로는 부적합하다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;수세의 Rancher, 레드햇의 OpenShift와 같은 플랫폼에서 제공하는 &lt;strong&gt;설치형 쿠버네티스&lt;/strong&gt;를 사용한다. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;허나 유료다.&lt;/code&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용하는 시스템에 쿠버네티스 클러스터를 &lt;strong&gt;자동으로 구성해주는 솔루션을 사용&lt;/strong&gt;한다. 주요 솔루션으로는 kubeadm, kops, KBIB, kubespray가 있다. 이 중 kubeadm이 가장 잘 알려져 있고, 사용자가 변경하기도 수월하며, 온프레미스와 클라우드를 모두 지원한다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;ul&gt;
  &lt;li&gt;쿠버네티스 클러스터 구성 솔루션 비교&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;구분&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;도커 스윔&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;메소스&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;노매드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;쿠버네티스&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;정보량&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;많음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;많음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 많음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;세부 설정 변경&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;가능함&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;가능함&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제한적으로 가능함&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;다양함&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사전 요구 조건&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;적음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 적음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;온프레미스 지원&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라우드 지원&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;안 됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;좋음&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;학습 곡선&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;매우 어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉬움&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;어려움&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;자동화 기능&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제공됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제공됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;쉽게 제공됨&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;제한적으로 제공됨&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;파드를-배포할-때&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;파드를 배포할 때&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;쿠버네스트의 구성 요소의 유기적인 연결관계를 그림으로 표현하면 다음과 같다.&lt;br /&gt;
그림에 표시된 숫자는 실제로 관리자나 개발자가 파드 배포 명령을 수행했을 때 실행되는 순서다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/images/kubernetes1.jpeg&quot; alt=&quot;img.png&quot; /&gt;&lt;/p&gt;

&lt;h4 style=&quot;color:MediumSlateBlue&quot;&gt;마스터 노드&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;⓪. kubectl&lt;/strong&gt; : 쿠버네티스 클러스터에 명령을 내리는 역할을 한다. 다른 구성 요소들과 다르게 바로 실행되는 명령 형태인 바이너리(binary)로 배포되기 때문에 마스터 노드에 있을 필요는 없다. 허나, 통상적으로 API 서버와 주로 통신하므로 마스터 노드에 구성하였다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;①. API 서버&lt;/strong&gt; : 쿠버네티스 클러스터의 중심 역할을 하는 통로이다. 주로 상태 값을 저장하는 etcd와 통신하지만, 그 밖의 요소들 또한 API 서버를 중심에 두고 통신하므로 API 서버의 역할이 매우 중요하다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;②. etcd&lt;/strong&gt; : 구성 요소들의 상태 값이 모두 저장되는 곳이다. 회사의 관리자가 모든 보고 내용을 기록하는 노트라고 생각하면 된다. 실제로 etcd 외의 다른 구성 요소는 상태 값을 관리하지 않는다. 그러므로 etcd의 정보만 백업되어 있다면 장애 상황에서도 쿠버네티스 클러스터는 복구할 수 있다. 또한 etcd는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;분산 저장이 가능한 key-value 저장소&lt;/code&gt;이므로, 복제해 여러 곳에 저장해 두면 하나의 etcd에서 장애가 나더라도 시스템의 가용성을 확보할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;③. 컨트롤러 매니저&lt;/strong&gt; : 컨트롤러 매니저는 쿠버네티스 클러스터의 오브젝트 상태를 관리한다. 예를 들어 워커 노드에서 통신이 되지 않는 경우, 상태 체크와 복구는 컨트롤러 매니어제 속한 노드 컨트롤러에서 이뤄진다. 다양한 상태 값을 관리하는 주체들이 컨트롤러 매니저에 소속되어 각자의 역할을 수행한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;④. 스케줄러&lt;/strong&gt; : 노드의 상태와 자원, 레이블, 요구 조건 등을 고려해 파드를 어떤 워커 노드에 생성할 것인지를 결정하고 할당한다. 스케줄러라는 이름에 맞게 파드를 조건에 맞는 워커 노드에 지정하고, 파드가 워커 노드에 할당되는 일정을 관리한다.&lt;/p&gt;

&lt;h4 style=&quot;color:MediumSlateBlue&quot;&gt;워커 노드&lt;/h4&gt;

&lt;p&gt;&lt;strong&gt;⑤. kubelet&lt;/strong&gt; : 파드의 구성 내용(PodSpec)을 받아서 컨테이너 런타임으로 전달하고, 파드 안의 컨테이너들이 정상적으로 작동하는지 모니터링 한다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;⑥. 컨테이너 런타임(CRI)&lt;/strong&gt; : 파드를 이루는 컨테이너의 실행을 담당한다. 파드 안에서 다양한 종류의 컨테이너가 문제 없이 작동하게 만드는 표준 인터페이스이다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;⑦. 파드(Pod)&lt;/strong&gt; : 한 개 이상의 컨테이너로 단일 목적의 일을 하기 위해서 모인 단위이다. 즉, 웹서버 역할을 할 수도 있고 로그나 데이터를 분석할 수도 있다. 중요한 것은 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;파드는 언제라도 죽을 수 있는 존재라는 점&lt;/code&gt;이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
조훈·심근우·문성주 (2021). 컨테이너 인프라 환경 구축을 위한 쿠버네티스/도커. 길벗&lt;/p&gt;
</description>
        <pubDate>Tue, 12 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/docker-kubernetes/kuberbetes/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/docker-kubernetes/kuberbetes/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>Docker-Kubernetes</category>
        
      </item>
    
      <item>
        <title>인프라 환경</title>
        <description>&lt;p&gt;컨테이너 인프라 환경은 컨테이너를 중심으로 구성된 인프라 환경이다. &lt;strong&gt;컨터이너(container)는 하나의 운영체제 커널에서 다른 프로세스에 영향을 받지 않고 독립적으로 실행되는 프로세스 상태를 의미&lt;/strong&gt;한다. 이렇게 구현된 컨테이너는 가상화 상태에서 동작하는 프로세스보다 가볍고 빠르게 동작한다.&lt;/p&gt;

&lt;h2 id=&quot;모놀리식-아키텍쳐monolithic-architecture&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;모놀리식 아키텍쳐(Monolithic Architecture)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;모놀리식 아키텍처는 하나의 큰 목적이 있는 서비스 또는 애플리케이션에 여러 기능이 통합돼 있는 구조를 의미&lt;/strong&gt;한다.&lt;/p&gt;

&lt;p&gt;모놀리식 아키텍처에서는 소프트웨어가 하나의 결합된 코드로 구성되기 때문에 초기 단계에서 설계하기 쉽고 개발이 단순하고 코드관리가 간편하다는 장점이 있다.&lt;/p&gt;

&lt;p&gt;하지만 서비스를 운영 하다보면 자연스레 수정사항이 많아지게 되는데, 이때 한 서비스를 수정하면 연관된 다른 서비스에 영향을 끼칠 가능성이 커지게 된다. 점점 기능이 추가될수록 초기에 단순했던 서비스 관계는 매우 복잡해질 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;마이크로서비스-아키텍쳐msa-microservice-architecture&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;마이크로서비스 아키텍쳐(MSA, MicroService Architecture)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;마이크로서비스 아키텍쳐는 시스템 전체가 하나의 목적을 지향하는 바는 모놀리식 아키텍쳐와 동일하지만, 개별 기능의 작은 서비스를 각각 개발해 연결하는 데서 차이가 있다&lt;/strong&gt;. 보안, 인증 등과 관련된 기능이 독립된 서비스를 구성하고 있으며 다른 서비스들도 독립적으로 동작할 수 있는 완결된 구조이다.&lt;/p&gt;

&lt;p&gt;이런 구조로 개발된 서비스는 재사용하기 쉽고, 향후 서비스가 변경됐을 때 다른 서비스에 영향을 끼칠 가능성이 줄어들어 사용량의 변화에 따라 특정 서비스만 확장할 수 있다.&lt;/p&gt;

&lt;p&gt;하지만 마이크로서비스 아키텍쳐는 모놀리식 아키텍처보다 복잡도가 높고, 각 서비스가 서로 유기적으로 통신하는 구조로 설계되기 때문에 네트워크를 통한 호출 횟수가 증가해 성능에 영향을 줄 수 있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;컨테이너-인프라-환경을-지원하는-도구&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;컨테이너 인프라 환경을 지원하는 도구&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;컨테이너 인프라 환경은 크게 &lt;strong&gt;컨테이너&lt;/strong&gt;, &lt;strong&gt;컨테이너 관리&lt;/strong&gt;, &lt;strong&gt;개발 환경 구성 및 배포 자동화&lt;/strong&gt;, &lt;strong&gt;모니터링&lt;/strong&gt;으로 구성되며, 이를 지원하는 도구는 아래와 같다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;도커docker&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;도커(Docker)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;도커는 컨테이너 환경에서 독립적으로 애플리케이션을 실행할 수 있도록 컨테이너를 만들고 관리하는 것을 도와주는 컨테이너 도구&lt;/strong&gt;이다.&lt;/p&gt;

&lt;p&gt;도커로 애플리케이션을 실행하면 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;운영체제 환경에 상관없이 독립적인 환경에서 일관된 결과를 보장&lt;/code&gt;한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;쿠버네티스kubernetes&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;쿠버네티스(Kubernetes)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;쿠버네티스는 다수의 컨테이너를 관리하는 데 사용된다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;컨테이너의 자동 배포와 배포된 컨테이너에 대한 동작 보증, 부하에 따른 동적 확장 등의 기능을 제공한다. 처음엔 다수의 컨테이너만 관리하는 도구였으나, 현재는 컨테이너 인프라 필요한 기능을 통합하고 관리하는 솔루션으로 발전하였다.&lt;/p&gt;

&lt;p&gt;쿠버네티스는 컨테이너 인프라를 기반으로 API 게이트웨이, 서비스 디스커버리, 이벤트 버스, 인증 및 결제 등의 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;다양한 서비스를 효율적으로 관리할 수 있는 환경을 제공하고 이를 내외부와 유연하게 연결&lt;/code&gt;해준다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;젠킨스jenkins&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;젠킨스(Jenkins)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;젠킨스는 지속적 통합(CI, Continuous Integration)과 지속적 배포(CD, Continuous Deployment)를 지원한다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;지속적 통합과 지속적 배포는 개발한 프로그램의 빌드, 테스트, 패키지화, 배포 단계를 모두 자동화해 개발 단계를 표준화한다. 개발된 코드의 빠른 적용과 효과적인 관리릍 통해 개발 생산성을 높이는 데 초점이 맞춰져있다. 즉, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;컨테이너 인프라 환경처럼 단일 기능을 빠르게 개발해 적용해야 하는 환경에 매우 적합한 도구&lt;/code&gt;이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h6 id=&quot;프로메테우스prometheus와-그라파나grafana&quot;&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;프로메테우스(Prometheus)와 그라파나(Grafana)&lt;/span&gt;&lt;/h6&gt;
&lt;p&gt;&lt;strong&gt;프로메테우스와 그라파나는 모니터링을 위한 도구이다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;프로메테우스는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;상태 데이터를 수집&lt;/code&gt;하고,&lt;br /&gt;
그라파나는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;프로메테우스로 수집한 데이터를 관리자가 보기 좋게 시각화&lt;/code&gt;한다.&lt;/p&gt;

&lt;p&gt;컨테이너 인프라 환경에서는 많은 종류의 소규모 기능이 각각 나뉘어 개발되기 때문에 중앙 모니터링이 필요한데, 이때 효율적으로 모니터링을 하는 방법 중 하나가 프로메테우스와 그라파나의 조합이다.&lt;/p&gt;

&lt;p&gt;프로메테우스와 그라파나는 컨테이너로 패키징되어 동작하며, 최소한의 자원으로 쿠버네티스 클러스터의 상태를 시각적으로 표현한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
조훈·심근우·문성주 (2021). 컨테이너 인프라 환경 구축을 위한 쿠버네티스/도커. 길벗&lt;/p&gt;

</description>
        <pubDate>Sun, 10 Oct 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/docker-kubernetes/infra/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/docker-kubernetes/infra/</guid>
        
        <category>2021년 10월</category>
        
        
        <category>Docker-Kubernetes</category>
        
      </item>
    
      <item>
        <title>상태 코드</title>
        <description>&lt;p&gt;HTTP 상태 코드는 크게 다섯가지로 나뉘는데, 아래에서 자세히 살펴보자&lt;/p&gt;

&lt;h2 id=&quot;100-199-정보성-상태-코드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;100-199: 정보성 상태 코드&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;정보성 상태 코드는 HTTP/1.1에서 도입되었다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;사유 구절&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;100&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Continue&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지는 계속 이어서 보내야 함을 의미한다. 서버는 반드시 요청을 받아 응답해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;101&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Swiching Protocols&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;100 Contine는 HTTP 클라이언트 애플리케이션이 서버에 엔터티 본문을 전송하기 전에 그 엔터티 본문을 서버가 받아들일 것인지 확인하려고 하는데, 그 확인 작업을 최적화하기 위한 의도로 도입 된 것이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;클라이언트와 100 Continue&lt;/span&gt;&lt;br /&gt;
만약 클라이언트가 엔터티를 서버에게 보내려고 하고, 그 전에 100 Continue 응답을 기다리겠다면, 클라이언트는 값을 100-Continue로 하는 Expect 요청 헤더를 보낼 필요가 있다. 만약 클라이언트가 엔터티를 보내지 않으려 한다면, 100-Continue Expect 헤더를 보내지 않아야 한다.&lt;br /&gt;
100-Continue는 여러 측면에서 최적화를 위한 것이다. 클라이언트 애플리케이션은 100-Continue를 서버가 다루거나 사용할 수 없는 큰 엔터티를 서버에게 보내지 않으려는 목적으로만 사용해야 한다. 이때, 100-Continue 값이 담긴 Expect 헤더를 보낸 클라이언트는 서버가 응답을 보내주기만을 막연히 기다리기만 하면 안 된다. 약간의 타임아웃 후에 클라이언트는 그냥 엔터티를 보내야 한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;서버와 100 Continue&lt;/span&gt;&lt;br /&gt;
서버가 100-Continue 값이 담긴 Expect 헤더가 포함된 요청을 받는다면, 100-Continue 응답 혹은 에러 코드로 답해야 한다. 서버는 절대 100-Continue 응답을 받을 것을 의도하지 않은 클라이언트에게 보내서는 안 된다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;200-299-성공-상태-코드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;200-299: 성공 상태 코드&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;클라이언트가 요청을 보내면, 그 요청을 대부분 성공한다. 서버는 대응하는 성공을 의미하는 상태 코드의 배열을 갖고 있으며, 각각 다른 종류의 요청에 대응한다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;사유 구절&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;200&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;OK&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청은 정상이고, 엔터티 본문은 요청된 리소스를 포함하고 있다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;201&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Created&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버 개체를 생성하는 요청을 위한 것. 응답은 생성된 리소스에 대한 최대한 구체적인 참조가 담긴 Location 헤더와 함께, 그 리소스를 참조할 수 있는 여러 URL를 엔터티 본문에 포함해야 한다. 서버는 상태 코드를 보내기에 앞서 반드시 객체를 생성해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;202&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Accepted&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청은 받아들여졌으나 서버는 아직 그에 대한 어떤 동작도 수행하지 않았다. 서버가 요청의 처리를 완료할 것인지에 대한 어떤 보장도 없다. 이것은 단지 요청이 받아들이기에 적합해 보인다는 의미일 뿐이다. 서버는 엔터티 본문에 요청에 대한 상태와 가급적이면 요청의 처리가 언제 완료될 것인지에 대한 추정(혹은 그에 대한 정보를 어디서 얻을 수 있는지)도 포함해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;203&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Non-Authoritative Infomation&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;엔터티 헤더에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다. 중개자가 리소스의 사본을 갖고 있었지만 리소스에 대한 메타 정보(헤더)를 검증하지 못한(혹은 안한) 경우 이런 일이 발생 할 수 있다. 이 응답 코드는 필수적으로 사용되어야 하는 것은 아니다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;204&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;No Content&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;응답 메시지는 헤더와 상태줄을 포함하지만 엔터티 본문은 포함하지 않는다. 주로 웹브라우저를 새 문서로 이동시키지 않고 갱신하고자 할 때(예: 폼 리프레시) 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;205&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Reset Content&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;주로 브라우저를 위해 사용되는 또 하나의 코드. 브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 모든 값을 비우라고 말한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;206&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Partial Content&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;범위 요청이 성공했음을 의미한다. Content-Rage와 Data 헤더를 반드시 포함해야 하며, Etag와 Content-Location 중 하나의 헤더도 반드시 포함해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;300-399-리다이렉션-상태-코드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;300-399: 리다이렉션 상태 코드&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그 리소스의 내용 대신 다른 대안 응답을 제공한다. 만약 리소스가 옮겨졌다면, 클라이언트에게 리소스가 옮겨졌으며 어디서 찾을 수 있는 지 알려주기 위해 리다이렉션 상태코드와 선택적으로 Location 헤더를 보낼 수 있다.&lt;br /&gt;
리다이렉션 상태 코드 중 몇몇은 리소스에 대한 애플리케이션의 로컬 복사본이 원래 서버와 비교했을 때 유효한지 확인하기 위해 사용된다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;사유 구절&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;300&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Multiple Choices&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 그 리소스의 목록과 함께 반환된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;301&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Moved Pemanently&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청한 URL이 옮겨졌을 때 사용한다. 응답은 Location 헤더에 현재 리소스가 존재하고 있는 URL을 포함해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;302&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Found&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;301 상태 코드와 같다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다. 이후의 요청에서는 원래 URL을 사용해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;303&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;See Other&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 말해주고자 할 때 사용된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;304&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Not Modified&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트는 헤더를 이용해 조건부 요청을 만들 수 있다. 만약 클라리언트가 GET과 같은 조건부 요청을 보냈고, 그 요청한 리소스가 최근에 수정된 일이 없다면, 이 코드는 리소스가 수정되지 않았음을 의미하게 된다. 이 상태 코드를 동반한 응답은 엔터티 본문을 가져서는 안 된다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;305&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Use Proxy&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;리소스가 반드시 프락시를 통해서 접근되어야 함을 나타내기 위해 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;306&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;(사용되지 않음)&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;현재는 사용되지 않는다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;307&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Temporary Redirect&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;301 상태 코드와 비슷하다 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다. 이후의 요총에서는 원래 URL을 사용해야 한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;400-499-클라이언트-에러-상태-코드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;400-499: 클라이언트 에러 상태 코드&lt;/span&gt;&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;사유 구절&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;400&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Bad Request&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트가 잘못된 요청을 보냈다고 말해준다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;401&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Unauthorized&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;리소스를 얻기 전에 클라리언트에게 스스로를 인증하라고 요구하는 내용의 응답을 적절한 헤더와 함께 반환한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;402&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Payment Required&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;현재 이 상태 코드는 쓰이지 않는다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;403&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Forbidden&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청이 서버에 의해 거부되었음을 알려주기 위해 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;404&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Not Found&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버가 요청한 URL을 찾을 수 없음을 알려주기 위해 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;405&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Method Not Allowed&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;요청한 URL에 대해, 지원하지 않는 메서드로 요청 받았을 때 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;406&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Not Acceptable&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트는 자신이 어떤 종류의 엔터티를 받아들이고자 하는지에 대해 매개변수로 명시할 수 있다. 이 코드는 주어진 URL에 대한 리소스 중 클라이언트가 받아들일 수 있는 것이 없는 경우 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;407&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Proxy Authentication Required&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;401 상태 코드와 같으나, 리소스에 대해 인증을 요구하는 프락시 서버를 위해 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;500-599-서버-에러-상태-코드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;500-599: 서버 에러 상태 코드&lt;/span&gt;&lt;/h2&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;상태 코드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;사유 구절&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;의미&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;500&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Intenal Server Error&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버가 요청을 처리할 수 없게 만드는 에러를 만났을 때 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;501&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Not Implemented&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;클라이언트가 서버의 능력을 넘은 요청을 했을 때 사용한다.(예: 서버가 지원하지 않는 메서드 사용)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;502&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Bad Gateway&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;프락시나 게이트웨이처럼 행동하는 서버가 그 요청 응답 연쇄에 있는 다른 링크로부터 가짜 응답에 맞닥뜨렸을 때 사용한다.(예: 만약 자신의 부모 게이트웨이에 접속하는 것이 불가능할 때)&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;503&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Service Unavailble&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;현재는 서버가 요청을 처리할 수 없지만, 나중에는 가능함을 의미하고자 할 때 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;504&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;Gateway Timeout&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;상태 코드 408과 비슷하지만, 다른 서버에게 요청을 보내고 응답을 기다리다 타임아웃이 발생한 게이트웨이나 프락시에서 온 응답이라는 점이 다르다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;505&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HTTP Version Not Supported&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버가 지원할 수 없거나 지원하지 않으려고 하는 버전의 프로토콜로 된 요청을 받았을 때 사용한다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
데이빗 고울리·브라이언 토티·마조리 세이어·세일루 레디·안슈 아가왈. (2014). HTTP 완벽 가이드. 프로그래밍인사이트&lt;/p&gt;

</description>
        <pubDate>Sun, 26 Sep 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/http/status-code/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/http/status-code/</guid>
        
        <category>2021년 09월</category>
        
        
        <category>HTTP</category>
        
      </item>
    
      <item>
        <title>HTTP 메서드</title>
        <description>&lt;h2 id=&quot;안전한-메서드safe-method&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;안전한 메서드(Safe Method)&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;HTTP는 안전한 메서드라 불리는 메서드의 집합을 정의한다. GET과 HEAD 메서드는 안전하다고 할 수 있는데, 이는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;GET이나 HEAD 메서드는 HTTP 요청의 결과로 서버에 어떤 작용도 없음을 의미&lt;/code&gt;한다.&lt;br /&gt;
안전한 메서드가 서버에 작용을 유발하지 않는 다는 보장은 없지만(웹 개발자가 어떻게 구현하냐에 달림), &lt;strong&gt;안전한 메서드의 목적은 서버에 어떤 영향을 줄 수 있는 안전하지 않은 메서드가 사용될 때 사용자들에게 그 사실을 알려주는 HTTP 애플리케이션을 만들 수 있도록 하는 것에 있다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;예를 들면 구매하기 버튼을 눌렀을 때, POST 요청(신용카드 정보)이 서버로 전송 될텐데 이때 서버에서 신용카드로 결제될 수 있다는 경고 메시지를 띄우는 일이있다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;get&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;GET&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;GET은 가장 흔히 사용되는 메서드&lt;/strong&gt;로서, 주로 서버에게 리소스를 달라고 요청하는데 사용된다. HTTP/1.1은 서버가 이 메서드를 구현할 것을 요구한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청 메시지
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;GET /seasonal/index.fall.html HTTP/1.1
Host: www.joes-hardware.com
Accept: *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;응답 메시지(엔터티 본문 포함)
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 200 OK
Content-type: text/html
Context-Length: 617
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;head&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;HEAD&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HEAD 메서드는 정확히 GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다&lt;/strong&gt;. 엔터티 본문은 반환되지 않고, 클라이언트가 리소스를 실제로 가져올 필요 없이 헤더만을 조사할 수 있도록 해준다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;리소스를 가져오지 않고도 그에 대해 무엇인가(타입)를 알아낼 수 있다.&lt;/li&gt;
  &lt;li&gt;응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.&lt;/li&gt;
  &lt;li&gt;헤더를 확인하여 리소스가 변경되었는지 확인할 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;서버 개발자들은 반드시 반환되는 헤더가 GET으로 얻는 것과 정확히 일치함을 보장&lt;/strong&gt;해야 하며, HTTP/1.1 준수를 위해서는 HEAD 메서드가 반드시 구현되어 있어야 한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청 메시지
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HEAD /seasonal/index-fall.html HTTP/1.1
Host: www.joes-hardware.com
Accept: *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;응답 메시지(엔터티 본문 없음)
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 200 OK
Content-Type: text/html
Context-Length: 617
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;put&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;PUT&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;GET 메서드가 서버로부터 문서를 읽어들이는데 반해 PUT 메서드는 서버에 문서를 쓴다&lt;/strong&gt;. 어떤 발행 시스템은 사용자가 PUT을 이용해 웹페이지를 만들고 웹 서버에 직접 게시할 수 있도록 해준다.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;PUT 메서드의 의미는 서버가 요청의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것이다&lt;/strong&gt;.&lt;br /&gt;
PUT은 컨텐츠를 변경할 수 있게 해주기 때문에, 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구하는 방식을 취한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청 메시지(서버는 ‘/product-list.txt’ 리소스를 갱신/생성하고 디스크에 저장한다.)
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;PUT /product-list.txt HTTP/1.1
Host: www.joes-hardware.com
Content-Type: text/plain
Content-length: 34
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;응답 메시지
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 201 Created
Location: http://www.joes-hardware.com/product-list.txt
Content-Type: text/plain
Content-Length: 47
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;post&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;POST&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;POST 메서드는 서버에 입력 데이터를 전송하기 위해 설계 되었다&lt;/strong&gt;. &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;PUT은 서버에 있는 리소스(예:파일)에 데이터를 입력하기 위해 사용된다면, POST는 서버에 데이터를 보내기 위해 사용&lt;/code&gt;&lt;br /&gt;
채워진 폼에 담긴 데이터는 서버로 전송되어 필요로 하는 곳(데이터를 처리할 서버 게이트웨이 프로그램 등)에 보낸다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청 메시지
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;POST /inventory-check.cgi HTTP/1.1
Host: www.joes-hardware.com
Content-Type: text/plain
Content-length: 18
item=bandsaw 2647(브라우저는 메시지의 엔터티 본문(body)에 데이터를 넣는다.)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;응답 메시지
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 200 OK
Content-type: text/plain
Context-length: 37
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;trace&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;TRACE&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;클라이언트가 어떤 요청을 할 때, 그 요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과할 수 있다. &lt;strong&gt;TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이게 되는지 알려준다&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;TRACE 요청은 목적지 서버에서 ‘루프백(loopback)’ 진단을 시작하는데, 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 돌려준다. 클라이언트는 자신과 목적지 서버 사이에 있는 모든 HTTP 애플리케이션의 요청/응답 연쇄를 따라가면서 자신이 보낸 메시지가 망가졌거나 수정되었는지, 만약 그렇다면 어떻게 변경되었는지 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;TRACE 메서드는 주로 진단을 위해 사용된다. 예를 들면 요청이 의도한 요청/응답 연쇄를 거쳐가는지 검사할 수 있고, 프락시나 다른 애플리케이션들이 요청에 어떤 영향을 미치는지 확인해보고자 할 때도 좋은 도구다.&lt;/p&gt;

&lt;p&gt;TRACE는 진단을 위해 사용할 때는 괜찮지만, 메서드를 구별할 수는 없기 때문에 여러 다른 종류의 요청(GET, HEAD, POST 등 각각 다른 메서드를 사용한)들을 일관되게 다룬다는 문제가 있다. 많은 HTTP 애플리케이션은 메서드에 따라 다르게 동작하는데, TRACE 요청을 처리할 것인지에 대해서는 일반적으로 중간 애플리케이션이 결정을 내린다. 또 TRACE 요청은 어떠한 엔터티 본문도 보낼 수 없다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;options&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;OPTIONS&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;OPTIONS 메서드는 웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다&lt;/strong&gt;. 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다(몇몇 서버는 특정 종류의 객체에 대해 특정 동작만을 지원).&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청 메시지
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;OPTIONS * HTTP/1.1
Host: www.joes-hardware.com
Accept: *
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;응답 메시지(OPTIONS 요청이 모든 리소스에 대한 것이므로, 서버는 자신의 리소스에 대해 지원하는 메서드의 목록을 반환하다.)
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 200 OK
Allow: GET, POST, PUT, OPTIONS(서버가 지원하는 메서드 목록 반환)
Context-length: 0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;delete&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;DELETE&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;DELETE 메서드는 서버에게 요청 URL로 지정한 리소스를 삭제할 것을 요청한다&lt;/strong&gt;. 그러나 HTTP 명세는 서버가 클라이언트에게 알리지 않고, 요청을 무시하는 것을 허용하기 때문에 삭제가 수행되는 것을 보장하지 못한다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청 메시지
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;DELETE /product-list.txt HTTP/1.1
Host: www.joes-hardware.com
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;응답 메시지(파일 ‘product-list’가 서버에서 지워졌다.)
    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;HTTP/1.1 200 OK
Content-type: text/plain
Context-Length: 54
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;확장-메서드&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;확장 메서드&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;확장 메서드는 HTTP/1.1 명세에 정의되지 않고, 개발자들에게 그들의 서버가 구현한 HTTP 서비스의 서버가 관리하는 리소스에 대한 능력을 확장하는 수단을 제공한다.&lt;/p&gt;

&lt;p&gt;확장 메서드의 대표적인 몇 가지는 아래 표와 같다.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;메서드&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;LOCK&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용자가 리소스를 잠글 수 있게 해준다. 예를 들어, 문서를 편집하는 동안 다른 사람이 동시에 같은 문서를 편집하지 못하도록 문서를 잠글 수 있다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MKCOL&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;사용자가 문서를 생성할 수 있게 해준다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;COPY&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버에 있는 리소스를 복사한다.&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;MOVE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버에 있는 리소스를 옮긴다.&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
데이빗 고울리·브라이언 토티·마조리 세이어·세일루 레디·안슈 아가왈. (2014). HTTP 완벽 가이드. 프로그래밍인사이트&lt;/p&gt;

</description>
        <pubDate>Wed, 22 Sep 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/http/method/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/http/method/</guid>
        
        <category>2021년 09월</category>
        
        
        <category>HTTP</category>
        
      </item>
    
      <item>
        <title>HTTP 메시지</title>
        <description>&lt;p&gt;HTTP가 인터넷의 배달원이라면, &lt;strong&gt;HTTP 메시지는 무언가를 담아 보내는 소포와 같다&lt;/strong&gt;.&lt;br /&gt;
이번에는 어떻게 메시지를 만들고 이해하는지에 대해 알아보자&lt;/p&gt;

&lt;h2 id=&quot;메시지의-흐름&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;메시지의 흐름&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HTTP 메시지는 HTTP 애플리케이션 간에 주고받은 데이터의 블록들이다&lt;/strong&gt;. 이 데이터의 블록들은 메시지의 내용과 의미를 설명하는 텍스트 메타 정보로 시작하고 그 다음에 선택적으로 데이터가 올 수 있다. 이 메시지는 클라이언트, 서버, 프락시 사이로 흐르며 ‘인바운드’, ‘아웃바운드’, ‘업스트림’, ‘다운스트림’은 메시지의 방향을 의미하는 용어다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;메시지는 원 서버 방향을 인바운드로 하여 송신된다.&lt;/span&gt;&lt;br /&gt;
HTTP는 &lt;strong&gt;트랜잭션 방향을 표현하기 위해 인바운드와 아웃바운드라는 표현을 사용&lt;/strong&gt;한다.&lt;br /&gt;
메시지가 원 서버로 향하는 것은 인바운드로 이동하는 것이고, 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것은 아웃바운드로 이동하는 것이다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;다운스트림으로 흐르는 메시지&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;요청 메시지냐 응답 메시지냐에 관계없이 모든 메시지는 다운스트림으로 흐른다&lt;/strong&gt;.&lt;br /&gt;
메시지의 발송자는 수신자의 업스트림이다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;메시지의-각-부분&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;메시지의 각 부분&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;HTTP 메시지는 단순한 데이터의 구조화된 블록이다&lt;/strong&gt;. 각 메시지는 클라이언트로부터의 요청이나 서버로부터의 응답 중 하나를 포함하며, 메시지는 &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;시작줄, 헤더블록, 본문&lt;/code&gt; 이렇게 세 부분으로 이루어진다.&lt;/p&gt;

&lt;p&gt;시작줄은 이것이 어떤 메시지인지 서술하며, 헤더 블록은 속성을, 본문은 데이터를 담거나 아예 없을 수도 있다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;메시지 문법&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;모든 HTTP 메시지는 요청 메시지나 응답 메시지로 분류된다&lt;/strong&gt;.&lt;br /&gt;
요청 메시지는 웹 서버에 어떤 동작을 요구하고, 응답 메시지는 요청의 결과를 클라이언트에게 돌려준다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;요청 메시지 형식&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;메서드&amp;gt;&amp;lt;요청URL&amp;gt;&amp;lt;버전&amp;gt;
&amp;lt;헤더&amp;gt;

&amp;lt;엔터티 본문&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;응답 메시지 형식&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;lt;버전&amp;gt;&amp;lt;상태코드&amp;gt;&amp;lt;사유 구절&amp;gt;
&amp;lt;헤더&amp;gt;

&amp;lt;엔터티 본문&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;메서드&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;요청의 시작줄은 메서드로 시작하며, 클라이언트가 서버에게 무엇을 해야 하는지 말한다&lt;/strong&gt;.&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;메서드 방식&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;설명&lt;/th&gt;
      &lt;th style=&quot;text-align: center&quot;&gt;메시지 본문(BODY) 여부&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;GET&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버에서 어떤 문서를 가져온다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;HEAD&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버에서 어떤 문서에 대해 헤더만 가져온다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;POST&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버가 처리해야 할 데이터를 보낸다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;PUT&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버에 요청 메시지의 본문을 저장한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;O&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;TRACE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;메시지가 프락시를 거쳐 서버에 도달하는 과정을 추적한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;OPTIONS&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버가 어떤 메서드를 수행할 수 있는지 확인한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;DELETE&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;서버에서 문서를 삭제한다.&lt;/td&gt;
      &lt;td style=&quot;text-align: center&quot;&gt;X&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;ul&gt;
  &lt;li&gt;메서드에 대한 내용은 별도 포스팅에 다룰 예정.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;요청 URL&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;요청 대상이 되는 리소스를 지칭하는 완전한 URL 혹은 URL의 경로 구성요소다&lt;/strong&gt;. 완전한 URL이 아닌 URL의 경로 구성요소라고 해도, 클라이언트가 서버와 직접 대화하고 있고 경로 구성요소가 리소스를 가리키는 절대 경로이기만 하면 대체로 문제가 없다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;상태 코드&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;상태코드는 클라이언트에게 요청 중에 무엇이 일어났는지 설명하는 세 자리 숫자다&lt;/strong&gt;.&lt;br /&gt;
상태 코드들은 세 자리 숫자로 된 그들의 코드 값을 기준으로 묶인다.&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;200에서 299까지의 상태 코드는 성공을 나타낸다.&lt;/li&gt;
  &lt;li&gt;300에서 399까지의 코드는 리소스가 옮겨졌음을 뜻한다.&lt;/li&gt;
  &lt;li&gt;400에서 499까지의 코드는 클라이언트가 뭔가 잘못된 요청을 했음을 의미한다.&lt;/li&gt;
  &lt;li&gt;500에서 599까지의 코드는 서버에서 뭔가 실패했음을 의미한다.&lt;br /&gt;
&lt;br /&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;사유 구절(reason-phrase)&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;숫자로 된 상태 코드의 의미를 사람이 이해할 수 있게 설명해주는 짧은 문구로, 상태 코드 이후부터 줄바꿈 문자열까지가 사유 구절이다&lt;/strong&gt;.&lt;br /&gt;
사유 구절은 오로지 사람에게 읽히기 위한 목적으로만 존재한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;헤더들&lt;/span&gt;&lt;br /&gt;
이름, 콜론(:), 선택적인 공백, 값, CRLF가 순서대로 나타나는 0개 이상의 헤더들, 이 헤더의 목록은 빈 줄(CRLF)로 끝나 헤더 목록의 끝과 엔터티 본문의 시작을 표시한다. HTTP/1.1과 같은 몇몇 버전의 HTTP는 요청이나 응답에 어떤 특정 헤더가 포함 되어야만 유효한 것으로 간주한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;엔터티 본문&lt;/span&gt;&lt;br /&gt;
엔터티 본문은 임의의 데이터 블록을 포함한다. 모든 메시지가 엔터티 본문을 갖는 것은 아니므로, 때때로 메시지는 그냥 CRLF으로 끝나게 된다. 헤더나 엔터티 본문이 없더라도 HTTP 헤더의 집합은 항상 빈 줄(CRLF)로 끝나야한다.&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;시작줄&quot;&gt;&lt;span style=&quot;color:MediumSeaGreen&quot;&gt;시작줄&lt;/span&gt;&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;모든 HTTP 메시지는 시작줄로 시작한다&lt;/strong&gt;.&lt;br /&gt;
요청 메시지의 시작줄은 무엇을 해야 하는지 말해주며, 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;요청줄&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;요청 메시지는 서버에게 리소스에 대해 무언가를 해달라고 부탁한다&lt;/strong&gt;. 요청 메시지의 시작줄 또는 요청줄에는 서버에서 어떤 동작이 일어나야 하는지 설명해주는 메서드와 그 동작에 대하 대상을 지칭하는 요청 URL이 들어 있다. 또한 요청줄은 클라이언트가 어떤 HTTP 버전인지 서버에게 알려주는 HTTP 버전도 포함한다.&lt;br /&gt;
&lt;br /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:DodgerBlue&quot;&gt;응답줄&lt;/span&gt;&lt;br /&gt;
&lt;strong&gt;응답 메시지는 수행 결과에 대한 상태 정보와 결과 데이터를 클라이언트에게 돌려준다&lt;/strong&gt;. 응답 메시지의 시작줄 또는 응답줄에는 응답 메시지에서 쓰인 HTTP의 버전, 숫자로 된 상태 코드, 수행 상태에 대해 설명해주는 텍스트로 된 사유구절이 포함된다.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;&lt;span style=&quot;color:DarkOrange&quot;&gt;reference&lt;/span&gt;&lt;br /&gt;
데이빗 고울리·브라이언 토티·마조리 세이어·세일루 레디·안슈 아가왈. (2014). HTTP 완벽 가이드. 프로그래밍인사이트&lt;/p&gt;

</description>
        <pubDate>Tue, 21 Sep 2021 00:00:00 +0900</pubDate>
        <link>https://hyuuny.github.io/http/message/</link>
        <guid isPermaLink="true">https://hyuuny.github.io/http/message/</guid>
        
        <category>2021년 09월</category>
        
        
        <category>HTTP</category>
        
      </item>
    
  </channel>
</rss>